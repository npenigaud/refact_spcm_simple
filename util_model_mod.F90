MODULE UTIL_MODEL_MOD

USE TYPE_MODEL, ONLY : MODEL

INTERFACE SAVE
MODULE PROCEDURE SAVE_MODEL
END INTERFACE

INTERFACE LOAD
MODULE PROCEDURE LOAD_MODEL
END INTERFACE

INTERFACE COPY
MODULE PROCEDURE COPY_MODEL
END INTERFACE

INTERFACE WIPE
MODULE PROCEDURE WIPE_MODEL
END INTERFACE



CONTAINS

SUBROUTINE SAVE_MODEL (KLUN, YD)
USE UTIL_MODEL_DIAGNOSTICS_TYPE_MOD
USE UTIL_MODEL_DYNAMICS_TYPE_MOD
USE UTIL_MODEL_GENERAL_CONF_TYPE_MOD
USE UTIL_TCST_MOD
IMPLICIT NONE
INTEGER, INTENT (IN) :: KLUN
TYPE (MODEL), INTENT (IN), TARGET :: YD
LOGICAL :: LYRCST
CALL SAVE (KLUN, YD%YRML_GCONF)
CALL SAVE (KLUN, YD%YRML_DYN)
CALL SAVE (KLUN, YD%YRML_DIAG)
LYRCST = ASSOCIATED (YD%YRCST)
WRITE (KLUN) LYRCST
IF (LYRCST) THEN
  CALL SAVE (KLUN, YD%YRCST)
ENDIF
END SUBROUTINE

SUBROUTINE LOAD_MODEL (KLUN, YD)
USE UTIL_MODEL_DIAGNOSTICS_TYPE_MOD
USE UTIL_MODEL_DYNAMICS_TYPE_MOD
USE UTIL_MODEL_GENERAL_CONF_TYPE_MOD
USE UTIL_TCST_MOD

IMPLICIT NONE
INTEGER, INTENT (IN) :: KLUN
TYPE (MODEL), INTENT (OUT), TARGET :: YD
LOGICAL :: LYRCST
CALL LOAD (KLUN, YD%YRML_GCONF)
CALL LOAD (KLUN, YD%YRML_DYN)
CALL LOAD (KLUN, YD%YRML_DIAG)
READ (KLUN) LYRCST
IF (LYRCST) THEN
  ALLOCATE (YD%YRCST)
  CALL LOAD (KLUN, YD%YRCST)
ELSE
  NULLIFY (YD%YRCST)
ENDIF
END SUBROUTINE


SUBROUTINE COPY_MODEL (YD, LDCREATED)
USE UTIL_MODEL_DIAGNOSTICS_TYPE_MOD
USE UTIL_MODEL_DYNAMICS_TYPE_MOD
USE UTIL_MODEL_GENERAL_CONF_TYPE_MOD
USE UTIL_TCST_MOD
IMPLICIT NONE
TYPE (MODEL), INTENT (IN), TARGET :: YD
LOGICAL, OPTIONAL, INTENT (IN) :: LDCREATED
LOGICAL :: LLCREATED
LOGICAL :: LYRCST

LLCREATED = .FALSE.
IF (PRESENT (LDCREATED)) THEN
  LLCREATED = LDCREATED
ENDIF
IF (.NOT. LLCREATED) THEN
  !$acc enter data create (YD)
  !$acc update device (YD)
ENDIF
CALL COPY (YD%YRML_GCONF, LDCREATED=.TRUE.)

CALL COPY (YD%YRML_DYN, LDCREATED=.TRUE.)

CALL COPY (YD%YRML_DIAG, LDCREATED=.TRUE.)

LYRCST = ASSOCIATED (YD%YRCST)
IF (LYRCST) THEN
  !$acc enter data create (YD%YRCST)
  !$acc update device (YD%YRCST)
  CALL COPY (YD%YRCST, LDCREATED=.TRUE.)
  !$acc enter data attach (YD%YRCST)
ENDIF

END SUBROUTINE

SUBROUTINE WIPE_MODEL (YD, LDDELETED)
USE UTIL_MODEL_DIAGNOSTICS_TYPE_MOD
USE UTIL_MODEL_DYNAMICS_TYPE_MOD
USE UTIL_MODEL_GENERAL_CONF_TYPE_MOD
USE UTIL_TCST_MOD
IMPLICIT NONE
TYPE (MODEL), INTENT (IN), TARGET :: YD
LOGICAL, OPTIONAL, INTENT (IN) :: LDDELETED
LOGICAL :: LLDELETED
LOGICAL :: LYRCST

CALL WIPE (YD%YRML_GCONF, LDDELETED=.TRUE.)

CALL WIPE (YD%YRML_DYN, LDDELETED=.TRUE.)

CALL WIPE (YD%YRML_DIAG, LDDELETED=.TRUE.)

LYRCST = ASSOCIATED (YD%YRCST)
IF (LYRCST) THEN
  !$acc exit data detach (YD%YRCST)
  CALL WIPE (YD%YRCST, LDDELETED=.TRUE.)
  !$acc exit data delete (YD%YRCST)
ENDIF

LLDELETED = .FALSE.
IF (PRESENT (LDDELETED)) THEN
  LLDELETED = LDDELETED
ENDIF
IF (.NOT. LLDELETED) THEN
  !$acc exit data delete (YD)
ENDIF
END SUBROUTINE



END MODULE
