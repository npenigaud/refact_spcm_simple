MODULE YOMVERT

USE PARKIND1 , ONLY : JPIM, JPRB, JPRD
USE YOMHOOK  , ONLY : LHOOK, DR_HOOK, JPHOOK
USE YOMCVER  , ONLY : TCVER

IMPLICIT NONE

SAVE

!     ------------------------------------------------------------------

!*    * DEFINING THE VERTICAL COORDINATE: A and B

!     VP00  : REFERENCE PRESSURE FOR DEFINING VERTICAL COORDINATE
!     VALH  : (0:NFLEVG)
!     VBH   : (0:NFLEVG) : B of the vertical coordinate
!     VAH   : (0:NFLEVG) ;  =VALH*VP00
!     VC    : (NFLEVG)   ;  =VAH(J)*VBH(J-1)-VAH(J-1)*VBH(J)
!     VDELB : (NFLEVG)   ;  =VBH(J)-VBH(J-1)
!     VDELA : (NFLEVG)   ;  =VAH(J)-VAH(J-1)
!     VAF   : like VAH but at full levels.
!     VBF   : like VBH but at full levels.
!     VRATH : VBH(J)*VP00/(VAH(J)+VBH(J)*VP00) with bounding near the top; always 0 at the top.
!     VRATF : full level version of VRATH, with bounding near the top.
!     TOPPRES: REFERENCE "EVANESCENT" PRESSURE
!              TOPPRES allows to solve some calculations of singularities
!              when the top pressure of the model is zero (for ex. in
!              GPPREF, GPXYB, SUNHBMAT).

!     WE HAVE THEN FOR THE HALF LEVEL PRESSURE : VAH + VBH*(SURFACE PRESSURE)


!! scalar reference values moved out from type TVAB
REAL(KIND=JPRB)         :: VP00
REAL(KIND=JPRB)         :: TOPPRES

TYPE TVAB
  REAL(KIND=JPRB), ALLOCATABLE :: VALH(:)
  REAL(KIND=JPRB), ALLOCATABLE :: VBH(:)
  REAL(KIND=JPRB), ALLOCATABLE :: VAH(:)
  REAL(KIND=JPRB), ALLOCATABLE :: VC(:)
  REAL(KIND=JPRB), ALLOCATABLE :: VAF(:)
  REAL(KIND=JPRB), ALLOCATABLE :: VBF(:)
  REAL(KIND=JPRB), ALLOCATABLE :: VDELA(:)
  REAL(KIND=JPRB), ALLOCATABLE :: VDELB(:)
END TYPE TVAB

!     ------------------------------------------------------------------

!*    * DEFINING THE VERTICAL COORDINATE: eta

!     VETAH : (0:NFLEVG) ; VERTICAL COORDINATE = VALH+VBH
!     VFE_ETAH : version of VETAH used for VFE operators.
!     VETAF : (0:NFLEVG+1) ; VERTICAL COORDINATE ON LAYERS.
!     VFE_ETAF : version of VETAF used for VFE operators.
!     VFE_RDETAH: VFE_RDETAH(jlev)=1/(VFE_ETAH(jlev)-VFE_ETAH(jlev-1))

TYPE TVETA
  REAL(KIND=JPRB), ALLOCATABLE :: VETAH(:)
  REAL(KIND=JPRB), ALLOCATABLE :: VFE_ETAH(:)
  REAL(KIND=JPRB), ALLOCATABLE :: VETAF(:)
  REAL(KIND=JPRB), ALLOCATABLE :: VFE_ETAF(:)
  REAL(KIND=JPRB), ALLOCATABLE :: VFE_RDETAH(:)
  REAL(KIND=JPRB), ALLOCATABLE :: VDETA_RATIO(:)
  REAL(KIND=JPRB), ALLOCATABLE :: VDETAH(:)
END TYPE TVETA

! -----------------------------------------------------------------------------

! * Finite element vertical discretisation 
! ----------------------------------------
! VFE_KNOT       : internal knots

! * Matricial operators related to vertical discretisation in finite elements
!   (to compute integrals or derivatives):
! -----------------------------------------------------------------------------
! * Integral operators on full levels
! RINTE    : without boundary conditions defined
! RINTBF00 : with explicitely given top and bottom BC;
!            input boundary conditions: X_0=0, X_{L+1}=0
!            output boundary conditions: KX_0=0
! RINTBF11 : with explicitely given top and bottom BC;
!            input boundary conditions: (dX/deta)_0=0, (dX/deta)_{L+1}=0
!            output boundary conditions: KX_0=0

! * First derivative operators on full levels
! RDERI    : without boundary conditions defined
! RDERB    = RDERBF00
! RDERBF00 : with explicitely given top and bottom BC;
!            input boundary conditions: X_0=0, X_{L+1}=X_L
!            output boundary conditions: none
! RDERBF01 : with explicitely given top and bottom BC;
!            input boundary conditions: X_0=0, (dX/deta)_{L+1}=0
!            output boundary conditions: DX_{L+1}=0
! RDERBF10 : with explicitely given top and bottom BC;
!            input boundary conditions: X_{L+1}=0, (dX/deta)_0=0
!            output boundary conditions: DX_0=0
! RDERBF11 : with explicitely given top and bottom BC;
!            input boundary conditions: (dX/deta)_0=0, (dX/deta)_{L+1}=0
!            output boundary conditions: DX_{L+1}=0

! * First derivative operators from full levels to half levels
! RDERBH00 : with explicitely given top and bottom BC;
!            input boundary conditions: X_0=0, X_L+1=X_L
!            output boundary conditions: none
! RDERBH01 : with explicitely given top and bottom BC;
!            input boundary conditions: X_0=0, (dX/deta)_{L+1}=0
!            output boundary conditions: none

! * Second derivative operators on full levels
! RDDERI   : without boundary conditions
! RDDERBF01: with explicitely given top and bottom BC;
!            input boundary conditions: X_0=0, (dX/deta)_{L+1}=0
!            output boundary conditions: DDX_{L+1}=0

! * Invertible matricial operators for transformations gw<->d
! RDERGW   : derivative operator 
! RINTGW   : integral operator 

! -----------------------------------------------------------------------------

TYPE TVFE
  REAL(KIND=JPRB),ALLOCATABLE :: VFE_KNOT(:)
  REAL(KIND=JPRD),ALLOCATABLE :: RINTE(:,:)
  REAL(KIND=JPRD),ALLOCATABLE :: RINTBF00 (:,:)
  REAL(KIND=JPRD),ALLOCATABLE :: RINTBF11 (:,:)
  REAL(KIND=JPRD),ALLOCATABLE :: RDERI(:,:)
  REAL(KIND=JPRD),ALLOCATABLE :: RDERB(:,:)
  REAL(KIND=JPRD),ALLOCATABLE :: RDERBF00 (:,:)
  REAL(KIND=JPRD),ALLOCATABLE :: RDERBF01 (:,:)
  REAL(KIND=JPRD),ALLOCATABLE :: RDERBF10 (:,:)
  REAL(KIND=JPRD),ALLOCATABLE :: RDERBF11 (:,:)
  REAL(KIND=JPRD),ALLOCATABLE :: RDERBH00 (:,:)
  REAL(KIND=JPRD),ALLOCATABLE :: RDERBH01 (:,:)
  REAL(KIND=JPRD),ALLOCATABLE :: RDDERI(:,:)
  REAL(KIND=JPRD),ALLOCATABLE :: RDDERBF01(:,:)
  REAL(KIND=JPRD),ALLOCATABLE :: RINTGW(:,:)
  REAL(KIND=JPRD),ALLOCATABLE :: RDERGW(:,:)
  REAL(KIND=JPRD),ALLOCATABLE :: RINTE_K(:,:)
  REAL(KIND=JPRD),ALLOCATABLE :: RINTE_I(:)
END TYPE TVFE

TYPE TVERTICAL_GEOM
  LOGICAL    :: LNONHYD_GEOM
  TYPE(TVAB) :: YRVAB 
  TYPE(TVETA):: YRVETA
  TYPE(TVFE) :: YRVFE 
  TYPE(TCVER) :: YRCVER
END TYPE TVERTICAL_GEOM

CONTAINS 

SUBROUTINE ALLOC_COPY_VERTICAL_GEOM( THIS,FROM )
  IMPLICIT NONE
  TYPE(TVERTICAL_GEOM),INTENT(INOUT) :: THIS
  TYPE(TVERTICAL_GEOM),INTENT(IN)    :: FROM

  THIS%LNONHYD_GEOM = FROM%LNONHYD_GEOM
  THIS%YRCVER = FROM%YRCVER

  CALL ALLOC_SIZEOF_1D(THIS%YRVAB%VALH         , FROM%YRVAB%VALH)
  CALL ALLOC_SIZEOF_1D(THIS%YRVAB%VAH          , FROM%YRVAB%VAH)
  CALL ALLOC_SIZEOF_1D(THIS%YRVAB%VBH          , FROM%YRVAB%VBH)
  CALL ALLOC_SIZEOF_1D(THIS%YRVAB%VC           , FROM%YRVAB%VC)
  CALL ALLOC_SIZEOF_1D(THIS%YRVAB%VDELB        , FROM%YRVAB%VDELB)
  CALL ALLOC_SIZEOF_1D(THIS%YRVETA%VETAH       , FROM%YRVETA%VETAH)
  CALL ALLOC_SIZEOF_1D(THIS%YRVETA%VETAF       , FROM%YRVETA%VETAF)
  CALL ALLOC_SIZEOF_1D(THIS%YRVETA%VDETAH      , FROM%YRVETA%VDETAH)
  CALL ALLOC_SIZEOF_1D(THIS%YRVETA%VDETA_RATIO , FROM%YRVETA%VDETA_RATIO)
  
  IF (FROM%YRCVER%LVERTFE) THEN
    CALL ALLOC_SIZEOF_1D(THIS%YRVETA%VFE_ETAH  , FROM%YRVETA%VFE_ETAH)
    CALL ALLOC_SIZEOF_1D(THIS%YRVETA%VFE_ETAF  , FROM%YRVETA%VFE_ETAF)
    CALL ALLOC_SIZEOF_1D(THIS%YRVAB%VAF        , FROM%YRVAB%VAF)
    CALL ALLOC_SIZEOF_1D(THIS%YRVAB%VBF        , FROM%YRVAB%VBF)
    CALL ALLOC_SIZEOF_1D(THIS%YRVAB%VDELA      , FROM%YRVAB%VDELA)
    CALL ALLOC_SIZEOF_1D(THIS%YRVETA%VFE_RDETAH, FROM%YRVETA%VFE_RDETAH)
    IF(.NOT.FROM%YRCVER%LVFE_ECMWF.AND.FROM%YRCVER%NVFE_TYPE>1)THEN
      CALL ALLOC_SIZEOF_1D(THIS%YRVFE%VFE_KNOT , FROM%YRVFE%VFE_KNOT)
    ENDIF

!*       1.3   VFE INTEGRAL AND DERIVATIVE OPERATORS
    IF (FROM%YRCVER%LVFE_COMPATIBLE) THEN
      CALL D_ALLOC_SIZEOF_2D(THIS%YRVFE%RINTE_K     ,  FROM%YRVFE%RINTE_K   )
      CALL ALLOC_SIZEOF_1D(THIS%YRVFE%RINTE_I       ,  FROM%YRVFE%RINTE_I   )
      IF (FROM%YRCVER%LVFE_ECMWF) THEN
        CALL D_ALLOC_SIZEOF_2D(THIS%YRVFE%RINTE     ,  FROM%YRVFE%RINTE     )
        CALL D_ALLOC_SIZEOF_2D(THIS%YRVFE%RDERI     ,  FROM%YRVFE%RDERI     )
      ELSE
        CALL D_ALLOC_SIZEOF_2D(THIS%YRVFE%RINTBF11  ,  FROM%YRVFE%RINTBF11  )
        CALL D_ALLOC_SIZEOF_2D(THIS%YRVFE%RDERBF11  ,  FROM%YRVFE%RDERBF11  )
      ENDIF
    ELSE
      IF (FROM%YRCVER%LVFE_ECMWF) THEN
        CALL D_ALLOC_SIZEOF_2D(THIS%YRVFE%RINTE     ,  FROM%YRVFE%RINTE     )
        CALL D_ALLOC_SIZEOF_2D(THIS%YRVFE%RDERI     ,  FROM%YRVFE%RDERI     )
        IF (FROM%LNONHYD_GEOM) THEN
          CALL D_ALLOC_SIZEOF_2D(THIS%YRVFE%RDERB   ,  FROM%YRVFE%RDERB     )
          CALL D_ALLOC_SIZEOF_2D(THIS%YRVFE%RDDERI  ,  FROM%YRVFE%RDDERI    )
        ENDIF
      ELSE
        CALL D_ALLOC_SIZEOF_2D(THIS%YRVFE%RINTBF11  ,  FROM%YRVFE%RINTBF11  )
        CALL D_ALLOC_SIZEOF_2D(THIS%YRVFE%RDERBF00  ,  FROM%YRVFE%RDERBF00  )
        CALL D_ALLOC_SIZEOF_2D(THIS%YRVFE%RDERBF01  ,  FROM%YRVFE%RDERBF01  )
        CALL D_ALLOC_SIZEOF_2D(THIS%YRVFE%RDERBF10  ,  FROM%YRVFE%RDERBF10  )
        CALL D_ALLOC_SIZEOF_2D(THIS%YRVFE%RDERBF11  ,  FROM%YRVFE%RDERBF11  )
        IF (FROM%LNONHYD_GEOM) THEN
          CALL D_ALLOC_SIZEOF_2D(THIS%YRVFE%RDERBH00  ,  FROM%YRVFE%RDERBH00  )
          CALL D_ALLOC_SIZEOF_2D(THIS%YRVFE%RDERBH01  ,  FROM%YRVFE%RDERBH01  )
          IF (FROM%YRCVER%LVFE_GW.OR.FROM%YRCVER%LVFE_GW_HALF) THEN
            CALL D_ALLOC_SIZEOF_2D(THIS%YRVFE%RINTBF00,  FROM%YRVFE%RINTBF00  )
            CALL D_ALLOC_SIZEOF_2D(THIS%YRVFE%RINTGW  ,  FROM%YRVFE%RINTGW    )
            CALL D_ALLOC_SIZEOF_2D(THIS%YRVFE%RDERGW  ,  FROM%YRVFE%RDERGW    )
          ENDIF
          CALL D_ALLOC_SIZEOF_2D(THIS%YRVFE%RDDERBF01 ,  FROM%YRVFE%RDDERBF01 )
        ENDIF
      ENDIF
    ENDIF
  ENDIF
END SUBROUTINE ALLOC_COPY_VERTICAL_GEOM 

SUBROUTINE DEALLOC_VERTICAL_GEOM( THIS )
  IMPLICIT NONE
  TYPE(TVERTICAL_GEOM),INTENT(INOUT) :: THIS
  
  !! YRVAB
  IF (ALLOCATED(THIS%YRVAB%VALH) ) DEALLOCATE(THIS%YRVAB%VALH  )
  IF (ALLOCATED(THIS%YRVAB%VBH)  ) DEALLOCATE(THIS%YRVAB%VBH   )
  IF (ALLOCATED(THIS%YRVAB%VAH)  ) DEALLOCATE(THIS%YRVAB%VAH   )
  IF (ALLOCATED(THIS%YRVAB%VC)   ) DEALLOCATE(THIS%YRVAB%VC    )
  IF (ALLOCATED(THIS%YRVAB%VAF)  ) DEALLOCATE(THIS%YRVAB%VAF   )
  IF (ALLOCATED(THIS%YRVAB%VBF)  ) DEALLOCATE(THIS%YRVAB%VBF   )
  IF (ALLOCATED(THIS%YRVAB%VDELA)) DEALLOCATE(THIS%YRVAB%VDELA )
  IF (ALLOCATED(THIS%YRVAB%VDELB)) DEALLOCATE(THIS%YRVAB%VDELB )

  !! YRVETA
  IF (ALLOCATED(THIS%YRVETA%VETAH)       ) DEALLOCATE(THIS%YRVETA%VETAH        )
  IF (ALLOCATED(THIS%YRVETA%VFE_ETAH)    ) DEALLOCATE(THIS%YRVETA%VFE_ETAH     )
  IF (ALLOCATED(THIS%YRVETA%VETAF)       ) DEALLOCATE(THIS%YRVETA%VETAF        )
  IF (ALLOCATED(THIS%YRVETA%VFE_ETAF)    ) DEALLOCATE(THIS%YRVETA%VFE_ETAF     )
  IF (ALLOCATED(THIS%YRVETA%VFE_RDETAH)  ) DEALLOCATE(THIS%YRVETA%VFE_RDETAH   )
  IF (ALLOCATED(THIS%YRVETA%VDETA_RATIO) ) DEALLOCATE(THIS%YRVETA%VDETA_RATIO  )
  IF (ALLOCATED(THIS%YRVETA%VDETAH)      ) DEALLOCATE(THIS%YRVETA%VDETAH       )  

  !! YRVFE
  IF (ALLOCATED(THIS%YRVFE%VFE_KNOT) ) DEALLOCATE(THIS%YRVFE%VFE_KNOT )
  IF (ALLOCATED(THIS%YRVFE%RINTE)    ) DEALLOCATE(THIS%YRVFE%RINTE    )
  IF (ALLOCATED(THIS%YRVFE%RINTBF00) ) DEALLOCATE(THIS%YRVFE%RINTBF00 )
  IF (ALLOCATED(THIS%YRVFE%RINTBF11) ) DEALLOCATE(THIS%YRVFE%RINTBF11 )  
  IF (ALLOCATED(THIS%YRVFE%RDERI)    ) DEALLOCATE(THIS%YRVFE%RDERI    )
  IF (ALLOCATED(THIS%YRVFE%RDERB)    ) DEALLOCATE(THIS%YRVFE%RDERB    )
  IF (ALLOCATED(THIS%YRVFE%RDERBF00) ) DEALLOCATE(THIS%YRVFE%RDERBF00 )
  IF (ALLOCATED(THIS%YRVFE%RDERBF01) ) DEALLOCATE(THIS%YRVFE%RDERBF01 )
  IF (ALLOCATED(THIS%YRVFE%RDERBF10) ) DEALLOCATE(THIS%YRVFE%RDERBF10 )
  IF (ALLOCATED(THIS%YRVFE%RDERBF11) ) DEALLOCATE(THIS%YRVFE%RDERBF11 )
  IF (ALLOCATED(THIS%YRVFE%RDERBH00) ) DEALLOCATE(THIS%YRVFE%RDERBH00 )
  IF (ALLOCATED(THIS%YRVFE%RDERBH01) ) DEALLOCATE(THIS%YRVFE%RDERBH01 )
  IF (ALLOCATED(THIS%YRVFE%RDDERI)   ) DEALLOCATE(THIS%YRVFE%RDDERI   )
  IF (ALLOCATED(THIS%YRVFE%RDDERBF01)) DEALLOCATE(THIS%YRVFE%RDDERBF01)
  IF (ALLOCATED(THIS%YRVFE%RINTGW))    DEALLOCATE(THIS%YRVFE%RINTGW   )
  IF (ALLOCATED(THIS%YRVFE%RDERGW))    DEALLOCATE(THIS%YRVFE%RDERGW   )
  IF (ALLOCATED(THIS%YRVFE%RINTE_K))   DEALLOCATE(THIS%YRVFE%RINTE_K  )
  IF (ALLOCATED(THIS%YRVFE%RINTE_I))   DEALLOCATE(THIS%YRVFE%RINTE_I  )

  
END SUBROUTINE DEALLOC_VERTICAL_GEOM 


!! helper routines
SUBROUTINE ALLOC_SIZEOF_1D(DEST,SOURCE)
  IMPLICIT NONE
  REAL(KIND=JPRB), ALLOCATABLE, INTENT(OUT) ::  DEST(:)
  REAL(KIND=JPRB), ALLOCATABLE, INTENT(IN)  ::  SOURCE(:)

  INTEGER :: DIM1_MIN, DIM1_MAX

  IF (ALLOCATED(SOURCE)) THEN
    !! allocate array with proper bounds
    DIM1_MIN = LBOUND(SOURCE,1)
    DIM1_MAX = UBOUND(SOURCE,1)
    ALLOCATE( DEST(DIM1_MIN:DIM1_MAX) ) 
    DEST(:) = SOURCE(:)
  ENDIF

END SUBROUTINE ALLOC_SIZEOF_1D

SUBROUTINE ALLOC_SIZEOF_2D(DEST,SOURCE)
  IMPLICIT NONE
  REAL(KIND=JPRB), ALLOCATABLE, INTENT(OUT) ::  DEST(:,:)
  REAL(KIND=JPRB), ALLOCATABLE, INTENT(IN)  ::  SOURCE(:,:)

  INTEGER :: DIM1_MIN, DIM1_MAX, DIM2_MIN, DIM2_MAX

  IF (ALLOCATED(SOURCE)) THEN
    !! allocate array with proper bounds
    DIM1_MIN = LBOUND(SOURCE,1)
    DIM1_MAX = UBOUND(SOURCE,1)
    DIM2_MIN = LBOUND(SOURCE,2)
    DIM2_MAX = UBOUND(SOURCE,2)
    ALLOCATE( DEST(DIM1_MIN:DIM1_MAX, DIM2_MIN:DIM2_MAX) ) 
    DEST(:,:) = SOURCE(:,:)
  ENDIF
END SUBROUTINE ALLOC_SIZEOF_2D

SUBROUTINE D_ALLOC_SIZEOF_2D(DEST,SOURCE)
  IMPLICIT NONE
  REAL(KIND=JPRD), ALLOCATABLE, INTENT(OUT) ::  DEST(:,:)
  REAL(KIND=JPRD), ALLOCATABLE, INTENT(IN)  ::  SOURCE(:,:)

  INTEGER :: DIM1_MIN, DIM1_MAX, DIM2_MIN, DIM2_MAX

  IF (ALLOCATED(SOURCE)) THEN
    !! allocate array with proper bounds
    DIM1_MIN = LBOUND(SOURCE,1)
    DIM1_MAX = UBOUND(SOURCE,1)
    DIM2_MIN = LBOUND(SOURCE,2)
    DIM2_MAX = UBOUND(SOURCE,2)
    ALLOCATE( DEST(DIM1_MIN:DIM1_MAX, DIM2_MIN:DIM2_MAX) ) 
    DEST(:,:) = SOURCE(:,:)
  ENDIF

END SUBROUTINE D_ALLOC_SIZEOF_2D

SUBROUTINE ALLOC_INIT_TVAB(KLEV,PVAH,PVBH,YDVAB)

  IMPLICIT NONE

  INTEGER(KIND=JPIM), INTENT(IN)    :: KLEV
  REAL(KIND=JPRB),    INTENT(IN)    :: PVAH(0:KLEV)
  REAL(KIND=JPRB),    INTENT(IN)    :: PVBH(0:KLEV)
  TYPE(TVAB),         INTENT(INOUT) :: YDVAB

  INTEGER(KIND=JPIM) :: JL
  REAL(KIND=JPHOOK) :: ZHOOK_HANDLE

  IF (LHOOK) CALL DR_HOOK('YOMVERT:ALLOC_INIT_TVAB',0,ZHOOK_HANDLE)

  ALLOCATE(YDVAB%VAH(0:KLEV))
  ALLOCATE(YDVAB%VBH(0:KLEV))
  ALLOCATE(YDVAB%VALH(0:KLEV))
  ALLOCATE(YDVAB%VC(KLEV))
  ALLOCATE(YDVAB%VDELA(KLEV))
  ALLOCATE(YDVAB%VDELB(KLEV))
  ALLOCATE(YDVAB%VAF(0:KLEV))
  ALLOCATE(YDVAB%VBF(0:KLEV))
  DO JL=0,KLEV
    YDVAB%VAH(JL)=PVAH(JL)
    YDVAB%VBH(JL)=PVBH(JL)
    YDVAB%VALH(JL)=YDVAB%VAH(JL)/VP00
  ENDDO
  DO JL=1,KLEV
    YDVAB%VC(JL)=YDVAB%VAH(JL)*YDVAB%VBH(JL-1)-YDVAB%VAH(JL-1)*YDVAB%VBH(JL)
    YDVAB%VAF(JL)=0.5_JPRB*(YDVAB%VAH(JL)+YDVAB%VAH(JL-1))
    YDVAB%VBF(JL)=0.5_JPRB*(YDVAB%VBH(JL)+YDVAB%VBH(JL-1))
    YDVAB%VDELA(JL)=YDVAB%VAH(JL)-YDVAB%VAH(JL-1)
    YDVAB%VDELB(JL)=YDVAB%VBH(JL)-YDVAB%VBH(JL-1)
  ENDDO
  
  IF (LHOOK) CALL DR_HOOK('YOMVERT:ALLOC_INIT_TVAB',1,ZHOOK_HANDLE)

END SUBROUTINE ALLOC_INIT_TVAB

SUBROUTINE DEALLOC_TVAB(YDVAB)

  IMPLICIT NONE

  TYPE(TVAB),         INTENT(INOUT) :: YDVAB

  REAL(KIND=JPHOOK) :: ZHOOK_HANDLE

  IF (LHOOK) CALL DR_HOOK('YOMVERT:DEALLOC_TVAB',0,ZHOOK_HANDLE)

  DEALLOCATE(YDVAB%VAH)
  DEALLOCATE(YDVAB%VBH)
  DEALLOCATE(YDVAB%VALH)
  DEALLOCATE(YDVAB%VC)
  DEALLOCATE(YDVAB%VDELA)
  DEALLOCATE(YDVAB%VDELB)
  DEALLOCATE(YDVAB%VAF)
  DEALLOCATE(YDVAB%VBF)

  IF (LHOOK) CALL DR_HOOK('YOMVERT:DEALLOC_TVAB',1,ZHOOK_HANDLE)

END SUBROUTINE DEALLOC_TVAB

END MODULE YOMVERT
