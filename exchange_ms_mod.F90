MODULE EXCHANGE_MS_MOD

USE GEOMETRY_MOD , ONLY : GEOMETRY
USE PARKIND1     , ONLY : JPIM, JPRB
USE YOMHOOK      , ONLY : LHOOK, DR_HOOK
USE YOMMP0       , ONLY : NPRTRV, NPRTRN, NPRCIDS, MYSETV, MYSETN, MYSETW, MYSETM, MYPROC

IMPLICIT NONE

INTEGER (KIND=JPIM), PARAMETER :: NEXCHANGE_MTOS = 111, NEXCHANGE_STOM = 222

TYPE FIELD3D
  REAL (KIND=JPRB), POINTER :: ZSP (:,:) => NULL (), ZSPG (:,:) => NULL ()
  CHARACTER (LEN=16) :: CNAME
END TYPE

TYPE FIELD2D
  REAL (KIND=JPRB), POINTER :: ZSP (:) => NULL (), ZSPG (:) => NULL ()
  CHARACTER (LEN=16) :: CNAME
  LOGICAL :: LBCAST = .FALSE.
END TYPE

INTEGER (KIND=JPIM), PARAMETER :: NFLDMAX = 100

TYPE FIELDLIST
  TYPE (FIELD3D) :: YL3D (NFLDMAX)
  INTEGER (KIND=JPIM) :: N3D = 0
  TYPE (FIELD2D) :: YL2D (NFLDMAX)
  INTEGER (KIND=JPIM) :: N2D = 0
END TYPE

ABSTRACT INTERFACE
  SUBROUTINE MESSAGE_FUN (YDGEOMETRY, KSPEC2V, KPTRSV, YDLIST, KJR, PBUF_M, KPEER, KSIZE, KWHAT)
  USE PARKIND1, ONLY : JPRB, JPIM
  USE GEOMETRY_MOD, ONLY : GEOMETRY
  IMPORT :: FIELDLIST
  TYPE (GEOMETRY)    ,INTENT(IN)              :: YDGEOMETRY
  INTEGER (KIND=JPIM),INTENT(IN)              :: KSPEC2V
  INTEGER (KIND=JPIM),INTENT(IN)              :: KPTRSV (:)
  TYPE (FIELDLIST)   ,INTENT(IN)              :: YDLIST
  INTEGER(KIND=JPIM) ,INTENT(IN)              :: KJR
  REAL(KIND=JPRB)                   ,OPTIONAL :: PBUF_M(:)
  INTEGER(KIND=JPIM) ,INTENT(OUT)   ,OPTIONAL :: KPEER, KSIZE
  INTEGER(KIND=JPIM) ,INTENT(IN)              :: KWHAT
  END SUBROUTINE
END INTERFACE

INTEGER (KIND=JPIM), PARAMETER :: NPACK = 11, NUNPACK = 22, NQUERY = 33

INTEGER(KIND=JPIM), EXTERNAL :: MYSENDSET, MYRECVSET

PRIVATE
PUBLIC :: EXCHANGE_MS, NEXCHANGE_MTOS, NEXCHANGE_STOM, FIELDLIST, &
 & ADD3DF, ADD3DFL, ADD2DF, ADD2DFL

CONTAINS

SUBROUTINE EXCHANGE_MS (YDGEOMETRY, YDLIST, KDIR, LDFULLM)

USE YOMTAG, ONLY : MTAGMS, MTAGSM

IMPLICIT NONE

TYPE(GEOMETRY)     ,INTENT(IN) :: YDGEOMETRY
TYPE (FIELDLIST)   ,INTENT(IN) :: YDLIST
INTEGER(KIND=JPIM) ,INTENT(IN) :: KDIR
LOGICAL, OPTIONAL  ,INTENT(IN) :: LDFULLM

#include "abor1.intfb.h"

INTEGER(KIND=JPIM) :: IPTRSV  (NPRTRV+1)
INTEGER(KIND=JPIM) :: ISPEC2V, JR
LOGICAL :: LLFULLM

INTEGER(KIND=JPIM) :: ISIZEMAX_M, INPROC_M, INRANK_M (NPRTRV-1), IPEER_M (NPRTRV-1), ISIZE_M (NPRTRV-1)
INTEGER(KIND=JPIM) :: ISIZEMAX_S, INPROC_S, INRANK_S (NPRTRV-1), IPEER_S (NPRTRV-1), ISIZE_S (NPRTRV-1)

REAL(KIND=JPRB) :: ZHOOK_HANDLE

IF (LHOOK) CALL DR_HOOK('EXCHANGE_MS',0,ZHOOK_HANDLE)

ASSOCIATE(YDDIMV=>YDGEOMETRY%YRDIMV,YDMP=>YDGEOMETRY%YRMP)
ASSOCIATE(NFLEVG=>YDDIMV%NFLEVG, NFLEVL=>YDDIMV%NFLEVL, NPTRLL=>YDMP%NPTRLL, NPSP=>YDMP%NPSP, NPSURF=>YDMP%NPSURF, &
& NPTRSV=>YDMP%NPTRSV, NPTRSVF=>YDMP%NPTRSVF, NSPEC2V=>YDMP%NSPEC2V, NSPEC2VF=>YDMP%NSPEC2VF)

LLFULLM=.FALSE.
IF(PRESENT(LDFULLM)) LLFULLM=LDFULLM

IF (LLFULLM) THEN
  ISPEC2V=NSPEC2VF
  IPTRSV(:)=NPTRSVF(:)
ELSE
  ISPEC2V=NSPEC2V
  IPTRSV(:)=NPTRSV(:)
ENDIF

ISIZEMAX_M = 0 
ISIZEMAX_S = 0 

INPROC_M = 0 
INPROC_S = 0 

DO JR = 1, NPRTRV-1 

  CALL MESSAGE_M (YDGEOMETRY, ISPEC2V, IPTRSV, YDLIST, JR, KSIZE=ISIZE_M (JR), KPEER=IPEER_M (JR), KWHAT=NQUERY)
  CALL MESSAGE_S (YDGEOMETRY, ISPEC2V, IPTRSV, YDLIST, JR, KSIZE=ISIZE_S (JR), KPEER=IPEER_S (JR), KWHAT=NQUERY)

  ISIZEMAX_M = MAX (ISIZEMAX_M, ISIZE_M(JR))
  ISIZEMAX_S = MAX (ISIZEMAX_S, ISIZE_S(JR))

  IF (ISIZE_M (JR) > 0) THEN
    INPROC_M=INPROC_M+1
    INRANK_M(INPROC_M)=JR
  ENDIF

  IF (ISIZE_S (JR) > 0) THEN
    INPROC_S=INPROC_S+1
    INRANK_S(INPROC_S)=JR
  ENDIF

ENDDO

SELECT CASE (KDIR)
  CASE (NEXCHANGE_MTOS) 
    CALL EXCHANGE (YDGEOMETRY, ISPEC2V, IPTRSV, YDLIST, KDIR, MTAGMS, &
                 & ISIZEMAX_M, INPROC_M, INRANK_M, IPEER_M, ISIZE_M, MESSAGE_M, &
                 & ISIZEMAX_S, INPROC_S, INRANK_S, IPEER_S, ISIZE_S, MESSAGE_S)
  CASE (NEXCHANGE_STOM)
    CALL EXCHANGE (YDGEOMETRY, ISPEC2V, IPTRSV, YDLIST, KDIR, MTAGSM, &
                 & ISIZEMAX_S, INPROC_S, INRANK_S, IPEER_S, ISIZE_S, MESSAGE_S, &
                 & ISIZEMAX_M, INPROC_M, INRANK_M, IPEER_M, ISIZE_M, MESSAGE_M)
  CASE DEFAULT
    CALL ABOR1 ('EXCHANGE_MS: UNEXPECTED KDIR')
END SELECT

END ASSOCIATE
END ASSOCIATE

IF (LHOOK) CALL DR_HOOK('EXCHANGE_MS',1,ZHOOK_HANDLE)

END SUBROUTINE EXCHANGE_MS

SUBROUTINE EXCHANGE (YDGEOMETRY, KSPEC2V, KPTRSV, YDLIST, KDIR, KTAG,     &
& KSIZEMAXSEND, KPROCSEND, KRANKSEND, KPEERSEND, KSIZESEND, MESSAGE_SEND, &
& KSIZEMAXRECV, KPROCRECV, KRANKRECV, KPEERRECV, KSIZERECV, MESSAGE_RECV)

USE MPL_MODULE   , ONLY : MPL_SEND, MPL_RECV, MPL_WAIT, MPL_WAITANY, JP_NON_BLOCKING_STANDARD, JP_BLOCKING_STANDARD

TYPE (GEOMETRY)   , INTENT (IN) :: YDGEOMETRY
INTEGER(KIND=JPIM), INTENT(IN)  :: KSPEC2V
INTEGER(KIND=JPIM), INTENT(IN)  :: KPTRSV (:)
TYPE (FIELDLIST)                :: YDLIST
INTEGER(KIND=JPIM), INTENT (IN) :: KDIR, KTAG
INTEGER(KIND=JPIM), INTENT (IN) :: KSIZEMAXSEND, KPROCSEND, KRANKSEND (:), KPEERSEND (:), KSIZESEND (:)
INTEGER(KIND=JPIM), INTENT (IN) :: KSIZEMAXRECV, KPROCRECV, KRANKRECV (:), KPEERRECV (:), KSIZERECV (:)
PROCEDURE (MESSAGE_FUN) :: MESSAGE_SEND, MESSAGE_RECV

REAL(KIND=JPRB) :: ZBUFSEND (KSIZEMAXSEND,KPROCSEND)
REAL(KIND=JPRB) :: ZBUFRECV (KSIZEMAXRECV,KPROCRECV)

INTEGER(KIND=JPIM) :: ISENDREQ (KPROCSEND)
INTEGER(KIND=JPIM) :: IRECVREQ (KPROCRECV)

INTEGER(KIND=JPIM) :: I, J, JR, ISP, JVERSP, JFLD
INTEGER(KIND=JPIM) :: ILEV1, ILEV2

! Use of blocking recv in transpostions (some networks do get flooded)
! 0 = full non-blocking (default)
! 1 = immediate sends, blocking receives
INTEGER(KIND=JPIM), PARAMETER :: NSPEC_SYNC_LEVEL = 0

REAL(KIND=JPRB) :: ZHOOK_HANDLE

IF (LHOOK) CALL DR_HOOK('EXCHANGE_MS:EXCHANGE',0,ZHOOK_HANDLE)

ASSOCIATE(NFLEVL=>YDGEOMETRY%YRDIMV%NFLEVL, NPTRLL=>YDGEOMETRY%YRMP%NPTRLL, NPSP=>YDGEOMETRY%YRMP%NPSP)

! * Recv loop .................................................

IF (NSPEC_SYNC_LEVEL == 0) THEN
  DO J=1,KPROCRECV
    JR=KRANKRECV(J)
    CALL MPL_RECV (ZBUFRECV (:,J), KSOURCE=KPEERRECV (JR), KMP_TYPE=JP_NON_BLOCKING_STANDARD,&
     & KREQUEST=IRECVREQ(J), KTAG=KTAG, CDSTRING='EXCHANGE_MS:')
  ENDDO
ENDIF

! * Pack and send loop .................................................

DO J=1,KPROCSEND
  JR=KRANKSEND(J)
  CALL MESSAGE_SEND (YDGEOMETRY, KSPEC2V, KPTRSV, YDLIST, JR, ZBUFSEND (:,J), KWHAT=NPACK)
  CALL MPL_SEND (ZBUFSEND (1:KSIZESEND (JR),J), KDEST=KPEERSEND (JR), KMP_TYPE=JP_NON_BLOCKING_STANDARD, &
   & KREQUEST=ISENDREQ(J), KTAG=KTAG, CDSTRING='EXCHANGE_MS:')
ENDDO

! * Transpose data used on local processor .................................................

ILEV1=NPTRLL(MYSETV)
ILEV2=ILEV1+NFLEVL-1

!$OMP PARALLEL DO SCHEDULE (STATIC) PRIVATE (JVERSP,ISP,JFLD)
DO JVERSP = 1, KSPEC2V
  ISP=KPTRSV(MYSETV)-1+JVERSP

#if defined(_OPENACC)
  DO JFLD = 1, YDLIST%N3D
    IF (KDIR == NEXCHANGE_MTOS) THEN
      YDLIST%YL3D (JFLD)%ZSPG (jversp,ILEV1:ILEV2) = YDLIST%YL3D (JFLD)%ZSP (isp,1:NFLEVL)
    ELSEIF (KDIR == NEXCHANGE_STOM) THEN
      YDLIST%YL3D (JFLD)%ZSP (isp,1:NFLEVL) = YDLIST%YL3D (JFLD)%ZSPG (jversp,ILEV1:ILEV2)
    ENDIF
  ENDDO
#else
  DO JFLD = 1, YDLIST%N3D
    IF (KDIR == NEXCHANGE_MTOS) THEN
      YDLIST%YL3D (JFLD)%ZSPG (ILEV1:ILEV2,JVERSP) = YDLIST%YL3D (JFLD)%ZSP (1:NFLEVL,ISP)
    ELSEIF (KDIR == NEXCHANGE_STOM) THEN
      YDLIST%YL3D (JFLD)%ZSP (1:NFLEVL,ISP) = YDLIST%YL3D (JFLD)%ZSPG (ILEV1:ILEV2,JVERSP)
    ENDIF
  ENDDO
#endif

  DO JFLD = 1, YDLIST%N2D
    IF ((NPSP == 1) .OR. & 
      &  YDLIST%YL2D (JFLD)%LBCAST) THEN ! Only KDIR=NEXCHANGE_STOM (LDNEEDPS=T)
      IF (KDIR == NEXCHANGE_MTOS) THEN
        YDLIST%YL2D (JFLD)%ZSPG (JVERSP) = YDLIST%YL2D (JFLD)%ZSP (ISP)
      ELSEIF (KDIR == NEXCHANGE_STOM) THEN
        YDLIST%YL2D (JFLD)%ZSP (ISP) = YDLIST%YL2D (JFLD)%ZSPG (JVERSP) 
      ENDIF
    ENDIF
  ENDDO

ENDDO
!$OMP END PARALLEL DO

! * Recv + unpack loop .................................................

IF (NSPEC_SYNC_LEVEL == 0) THEN

  DO I=1,KPROCRECV
    CALL MPL_WAITANY (KREQUEST=IRECVREQ, KINDEX=J, CDSTRING='EXCHANGE_MS: WAIT FOR RECEIVES')
    JR=KRANKRECV (J)
    CALL MESSAGE_RECV (YDGEOMETRY, KSPEC2V, KPTRSV, YDLIST, JR, ZBUFRECV (:,J), KWHAT=NUNPACK)
  ENDDO

  CALL MPL_WAIT (KREQUEST=ISENDREQ, CDSTRING='EXCHANGE_MS: WAIT FOR SENDS')

ELSE

  DO J=1,KPROCRECV
    JR=KRANKRECV(J)
    CALL MPL_RECV (ZBUFRECV (:,J), KSOURCE=KPEERRECV (JR), KMP_TYPE=JP_BLOCKING_STANDARD, &
     & KTAG=KTAG, CDSTRING='EXCHANGE_MS:')
    CALL MESSAGE_RECV (YDGEOMETRY, KSPEC2V, KPTRSV, YDLIST, JR, ZBUFRECV (:,JR), KWHAT=NUNPACK)
  ENDDO

ENDIF

END ASSOCIATE

IF (LHOOK) CALL DR_HOOK('EXCHANGE_MS:EXCHANGE',1,ZHOOK_HANDLE)

END SUBROUTINE EXCHANGE

SUBROUTINE MESSAGE_M (YDGEOMETRY, KSPEC2V, KPTRSV, YDLIST, KJR, PBUF_M, KPEER, KSIZE, KWHAT)

TYPE (GEOMETRY)    ,INTENT(IN)              :: YDGEOMETRY
INTEGER(KIND=JPIM), INTENT(IN)              :: KSPEC2V
INTEGER(KIND=JPIM), INTENT(IN)              :: KPTRSV (:)
TYPE (FIELDLIST)   ,INTENT(IN)              :: YDLIST
INTEGER(KIND=JPIM) ,INTENT(IN)              :: KJR
REAL(KIND=JPRB)                   ,OPTIONAL :: PBUF_M(:)
INTEGER(KIND=JPIM) ,INTENT(OUT)   ,OPTIONAL :: KPEER, KSIZE
INTEGER(KIND=JPIM) ,INTENT(IN)              :: KWHAT

#include "set2pe.intfb.h"

INTEGER(KIND=JPIM) :: IPOS, IOFF, ILEN, ISENDSET, JFLD
INTEGER(KIND=JPIM) :: ISPE, ISPEL, ISPE1, ISPE2

REAL(KIND=JPRB) :: ZHOOK_HANDLE

IF (LHOOK) CALL DR_HOOK('EXCHANGE_MS:MESSAGE_M',0,ZHOOK_HANDLE)

ASSOCIATE(NFLEVL=>YDGEOMETRY%YRDIMV%NFLEVL, NPSP=>YDGEOMETRY%YRMP%NPSP)

ISENDSET=MYSENDSET(NPRTRV,MYSETV,KJR)

IF (PRESENT (KPEER)) THEN
  CALL SET2PE (KPEER, 0, 0, MYSETW, ISENDSET)
  KPEER = NPRCIDS (KPEER)
ENDIF

ISPE1=KPTRSV(ISENDSET)
ISPE2=KPTRSV(ISENDSET+1)-1
ISPEL=ISPE2-ISPE1+1 ! KSPEC2V on remote task

IOFF = 0

DO JFLD = 1, YDLIST%N2D
  IF ((NPSP == 1) .OR. &
    &  YDLIST%YL2D (JFLD)%LBCAST) THEN ! Only for KWHAT == NUNPACK (KDIR=NEXCHANGE_STOM)
    IF (KWHAT == NPACK) THEN
      PBUF_M (IOFF+1:IOFF+ISPEL) = YDLIST%YL2D (JFLD)%ZSP (ISPE1:ISPE2) 
    ELSEIF (KWHAT == NUNPACK) THEN
      YDLIST%YL2D (JFLD)%ZSP (ISPE1:ISPE2) = PBUF_M (IOFF+1:IOFF+ISPEL)
    ENDIF
    IOFF = IOFF + ISPEL
  ENDIF
ENDDO

ILEN = NFLEVL * YDLIST%N3D

IF (KWHAT /= NQUERY) THEN
!$OMP PARALLEL DO SCHEDULE(STATIC) PRIVATE (ISPE,IPOS,JFLD)
  DO ISPE = ISPE1,ISPE2
    IPOS=IOFF+(ISPE-ISPE1)*ILEN
    DO JFLD = 1, YDLIST%N3D
#if defined(_OPENACC)
      IF (KWHAT == NPACK) THEN
        PBUF_M(IPOS+1:IPOS+NFLEVL) = YDLIST%YL3D (JFLD)%ZSP (ispe,1:NFLEVL)
      ELSEIF (KWHAT == NUNPACK) THEN
        YDLIST%YL3D (JFLD)%ZSP (ispe,1:NFLEVL) = PBUF_M(IPOS+1:IPOS+NFLEVL) 
      ENDIF
#else
      IF (KWHAT == NPACK) THEN
        PBUF_M(IPOS+1:IPOS+NFLEVL) = YDLIST%YL3D (JFLD)%ZSP (1:NFLEVL,ISPE)
      ELSEIF (KWHAT == NUNPACK) THEN
        YDLIST%YL3D (JFLD)%ZSP (1:NFLEVL,ISPE) = PBUF_M(IPOS+1:IPOS+NFLEVL) 
      ENDIF
#endif
      IPOS = IPOS + NFLEVL
    ENDDO
  ENDDO
!$OMP END PARALLEL DO
ENDIF

IF (PRESENT (KSIZE)) KSIZE = IOFF + ISPEL * ILEN

END ASSOCIATE

IF (LHOOK) CALL DR_HOOK('EXCHANGE_MS:MESSAGE_M',1,ZHOOK_HANDLE)

END SUBROUTINE MESSAGE_M 

SUBROUTINE MESSAGE_S (YDGEOMETRY, KSPEC2V, KPTRSV, YDLIST, KJR, PBUF_S, KPEER, KSIZE, KWHAT)

TYPE (GEOMETRY)    ,INTENT(IN)              :: YDGEOMETRY
INTEGER(KIND=JPIM), INTENT(IN)              :: KSPEC2V
INTEGER(KIND=JPIM), INTENT(IN)              :: KPTRSV (:)
TYPE (FIELDLIST)   ,INTENT(IN)              :: YDLIST
INTEGER(KIND=JPIM) ,INTENT(IN)              :: KJR
REAL(KIND=JPRB)                   ,OPTIONAL :: PBUF_S(:)
INTEGER(KIND=JPIM) ,INTENT(OUT)   ,OPTIONAL :: KPEER, KSIZE
INTEGER(KIND=JPIM) ,INTENT(IN)              :: KWHAT

#include "set2pe.intfb.h"

INTEGER(KIND=JPIM) :: ISPE, ILEVL, IPOS, ILEN, IOFF, IRECVSET, JFLD
INTEGER(KIND=JPIM) :: ILEV1, ILEV2

REAL(KIND=JPRB) :: ZHOOK_HANDLE

IF (LHOOK) CALL DR_HOOK('EXCHANGE_MS:MESSAGE_S',0,ZHOOK_HANDLE)

ASSOCIATE(YDMP=>YDGEOMETRY%YRMP)
ASSOCIATE(NPTRLL=>YDMP%NPTRLL, NPSURF=>YDMP%NPSURF)

IRECVSET=MYRECVSET(NPRTRN,MYSETN,KJR)

IF (PRESENT (KPEER)) THEN
  CALL SET2PE (KPEER, 0, 0, MYSETM, IRECVSET)
  KPEER = NPRCIDS (KPEER)
ENDIF

ILEV1=NPTRLL(IRECVSET)
ILEV2=NPTRLL(IRECVSET+1)-1
ILEVL=ILEV2-ILEV1+1 ! NFLEVL on remote task

IOFF = 0

DO JFLD = 1, YDLIST%N2D
  IF ((NPSURF (IRECVSET) == 1) .OR. &
    &  YDLIST%YL2D (JFLD)%LBCAST) THEN ! Only for KWHAT == NPACK (KDIR=NEXCHANGE_STOM)
    IF (KWHAT == NPACK) THEN
      PBUF_S(IOFF+1:IOFF+KSPEC2V) = YDLIST%YL2D (JFLD)%ZSPG (1:KSPEC2V) 
    ELSEIF (KWHAT == NUNPACK) THEN
      YDLIST%YL2D (JFLD)%ZSPG (1:KSPEC2V) = PBUF_S(IOFF+1:IOFF+KSPEC2V)
    ENDIF
    IOFF = IOFF + KSPEC2V
  ENDIF
ENDDO

ILEN = ILEVL * YDLIST%N3D

IF (KWHAT /= NQUERY) THEN
!$OMP PARALLEL DO SCHEDULE(STATIC) PRIVATE(ISPE,IPOS,JFLD) 
  DO ISPE = 1, KSPEC2V
    IPOS=IOFF+ILEN*(ISPE-1)
    DO JFLD = 1, YDLIST%N3D
#if defined(_OPENACC)
      IF (KWHAT == NPACK) THEN
        PBUF_S(IPOS+1:IPOS+ILEVL) = YDLIST%YL3D (JFLD)%ZSPG (ispe,ILEV1:ILEV2) 
      ELSEIF (KWHAT == NUNPACK) THEN
        YDLIST%YL3D (JFLD)%ZSPG (ispe,ILEV1:ILEV2) = PBUF_S(IPOS+1:IPOS+ILEVL)
      ENDIF
#else
      IF (KWHAT == NPACK) THEN
        PBUF_S(IPOS+1:IPOS+ILEVL) = YDLIST%YL3D (JFLD)%ZSPG (ILEV1:ILEV2,ISPE) 
      ELSEIF (KWHAT == NUNPACK) THEN
        YDLIST%YL3D (JFLD)%ZSPG (ILEV1:ILEV2,ISPE) = PBUF_S(IPOS+1:IPOS+ILEVL)
      ENDIF
#endif
      IPOS = IPOS + ILEVL
    ENDDO
  ENDDO
!$OMP END PARALLEL DO
ENDIF

IF (PRESENT (KSIZE)) KSIZE = IOFF + KSPEC2V * ILEN

END ASSOCIATE
END ASSOCIATE

IF (LHOOK) CALL DR_HOOK('EXCHANGE_MS:MESSAGE_S',1,ZHOOK_HANDLE)

END SUBROUTINE MESSAGE_S

SUBROUTINE ADD2DF (YDLIST, PSP, PSPG, CDNAME, LDBCAST)

TYPE (FIELDLIST)                                 :: YDLIST
REAL (KIND=JPRB)               ,OPTIONAL ,TARGET :: PSP (:), PSPG (:)
CHARACTER(LEN=*)  ,INTENT(IN)                    :: CDNAME
LOGICAL           ,INTENT(IN)  ,OPTIONAL         :: LDBCAST

REAL(KIND=JPRB) :: ZHOOK_HANDLE

IF (LHOOK) CALL DR_HOOK('EXCHANGE_MS:ADD2DF',0,ZHOOK_HANDLE)

IF (.NOT. PRESENT (PSP)) GOTO 999

IF (PRESENT(PSP) .NEQV. PRESENT (PSPG)) THEN
  CALL ABOR1('EXCHANGE_MS: '//TRIM (CDNAME)//' AND '//TRIM (CDNAME)//'G HAVE TO BE BOTH PRESENT')  
ENDIF

YDLIST%N2D = YDLIST%N2D + 1

IF (YDLIST%N2D > SIZE (YDLIST%YL2D)) THEN
  CALL ABOR1 ('EXCHANGE_MS:ADD2DF: LIST IS FULL')
ENDIF

ASSOCIATE (YL2D => YDLIST%YL2D (YDLIST%N2D))
  YL2D%CNAME = CDNAME
  YL2D%ZSP   => PSP
  YL2D%ZSPG  => PSPG
  IF (PRESENT (LDBCAST)) YL2D%LBCAST = LDBCAST
END ASSOCIATE

999 CONTINUE

IF (LHOOK) CALL DR_HOOK('EXCHANGE_MS:ADD2DF',1,ZHOOK_HANDLE)

END SUBROUTINE

SUBROUTINE ADD3DF (YDLIST, PSP, PSPG, CDNAME)

TYPE (FIELDLIST)                                :: YDLIST
REAL (KIND=JPRB)              ,OPTIONAL ,TARGET :: PSP (:,:), PSPG (:,:)
CHARACTER(LEN=*) ,INTENT(IN)                    :: CDNAME

REAL(KIND=JPRB) :: ZHOOK_HANDLE

IF (LHOOK) CALL DR_HOOK('EXCHANGE_MS:ADD3DF',0,ZHOOK_HANDLE)

IF (.NOT. PRESENT (PSP)) GOTO 999

IF (PRESENT(PSP) .NEQV. PRESENT (PSPG)) THEN
  CALL ABOR1('EXCHANGE_MS: '//TRIM (CDNAME)//' AND '//TRIM (CDNAME)//'G HAVE TO BE BOTH PRESENT')  
ENDIF

YDLIST%N3D = YDLIST%N3D + 1

IF (YDLIST%N3D > SIZE (YDLIST%YL3D)) THEN
  CALL ABOR1 ('EXCHANGE_MS:ADD3DF: LIST IS FULL')
ENDIF

ASSOCIATE (YL3D => YDLIST%YL3D (YDLIST%N3D))
  YL3D%CNAME = CDNAME
  YL3D%ZSP   => PSP
  YL3D%ZSPG  => PSPG
END ASSOCIATE

999 CONTINUE

IF (LHOOK) CALL DR_HOOK('EXCHANGE_MS:ADD3DF',1,ZHOOK_HANDLE)

END SUBROUTINE

SUBROUTINE ADD2DFL (YDLIST, PSP, PSPG, CDNAME, LDMASK)

TYPE (FIELDLIST)                                :: YDLIST
REAL (KIND=JPRB)              ,OPTIONAL, TARGET :: PSP (:,:), PSPG (:,:)
CHARACTER(LEN=*) ,INTENT(IN)                    :: CDNAME
LOGICAL          ,INTENT(IN)  ,OPTIONAL         :: LDMASK(:)

INTEGER (KIND=JPIM) :: JFLD, JFLDG
CHARACTER (LEN=16) :: CLNAME

REAL(KIND=JPRB) :: ZHOOK_HANDLE

IF (LHOOK) CALL DR_HOOK('EXCHANGE_MS:ADD2DFL',0,ZHOOK_HANDLE)

IF (.NOT. PRESENT (PSP)) GOTO 999

IF (PRESENT(PSP) .NEQV. PRESENT (PSPG)) THEN
  CALL ABOR1('EXCHANGE_MS:ADD2DFL: '//TRIM (CDNAME)//' AND '//TRIM (CDNAME)//'G HAVE TO BE BOTH PRESENT')  
ENDIF

IF (PRESENT (LDMASK)) THEN
  IF (SIZE (LDMASK) /= SIZE (PSP, 2)) THEN
    CALL ABOR1('EXCHANGE_MS:ADD2DFL: DIMENSION MISMATCH FOR '//TRIM (CDNAME))
  ENDIF
  IF (COUNT (LDMASK) /= SIZE (PSPG, 2)) THEN
    CALL ABOR1('EXCHANGE_MS:ADD2DFL: DIMENSION MISMATCH FOR '//TRIM (CDNAME))
  ENDIF
ELSE
  IF (SIZE (PSPG, 2) /= SIZE (PSP, 2)) THEN
    CALL ABOR1('EXCHANGE_MS:ADD2DFL: DIMENSION MISMATCH FOR '//TRIM (CDNAME))
  ENDIF
ENDIF

JFLDG = 0
DO JFLD = 1, SIZE (PSP, 2)

  IF (PRESENT (LDMASK)) THEN
    IF (.NOT. LDMASK (JFLD)) CYCLE
  ENDIF

  JFLDG = JFLDG + 1
  YDLIST%N2D = YDLIST%N2D + 1
  
  IF (YDLIST%N2D > SIZE (YDLIST%YL2D)) THEN
    CALL ABOR1 ('EXCHANGE_MS:ADD2DFL: LIST IS FULL')
  ENDIF
  
  ASSOCIATE (YL2D => YDLIST%YL2D (YDLIST%N2D))
    WRITE (YL2D%CNAME, '(A,".",I4.4)') JFLD
    YL2D%ZSP   => PSP (:,JFLD)
    YL2D%ZSPG  => PSPG (:,JFLDG)
  END ASSOCIATE

ENDDO

999 CONTINUE

IF (LHOOK) CALL DR_HOOK('EXCHANGE_MS:ADD2DFL',1,ZHOOK_HANDLE)

END SUBROUTINE

SUBROUTINE ADD3DFL (YDLIST, PSP, PSPG, CDNAME, LDMASK)

TYPE (FIELDLIST)                                  :: YDLIST
REAL (KIND=JPRB)                ,OPTIONAL, TARGET :: PSP (:,:,:), PSPG (:,:,:)
CHARACTER(LEN=*) ,INTENT(IN)                      :: CDNAME
LOGICAL          ,INTENT(IN)    ,OPTIONAL         :: LDMASK(:)

INTEGER (KIND=JPIM) :: JFLD, JFLDG
CHARACTER (LEN=16) :: CLNAME

REAL(KIND=JPRB) :: ZHOOK_HANDLE

IF (LHOOK) CALL DR_HOOK('EXCHANGE_MS:ADD3DFL',0,ZHOOK_HANDLE)

IF (.NOT. PRESENT (PSP)) GOTO 999

IF (PRESENT(PSP) .NEQV. PRESENT (PSPG)) THEN
  CALL ABOR1('EXCHANGE_MS:ADD3DFL: '//TRIM (CDNAME)//' AND '//TRIM (CDNAME)//'G HAVE TO BE BOTH PRESENT')  
ENDIF

IF (PRESENT (LDMASK)) THEN
  IF (SIZE (LDMASK) /= SIZE (PSP, 3)) THEN
    CALL ABOR1('EXCHANGE_MS:ADD3DFL: DIMENSION MISMATCH FOR '//TRIM (CDNAME))
  ENDIF
  IF (COUNT (LDMASK) /= SIZE (PSPG, 3)) THEN
    CALL ABOR1('EXCHANGE_MS:ADD3DFL: DIMENSION MISMATCH FOR '//TRIM (CDNAME))
  ENDIF
ELSE
  IF (SIZE (PSPG, 3) /= SIZE (PSP, 3)) THEN
    CALL ABOR1('EXCHANGE_MS:ADD3DFL: DIMENSION MISMATCH FOR '//TRIM (CDNAME))
  ENDIF
ENDIF

JFLDG = 0
DO JFLD = 1, SIZE (PSP, 3)

  IF (PRESENT (LDMASK)) THEN
    IF (.NOT. LDMASK (JFLD)) CYCLE
  ENDIF

  JFLDG = JFLDG + 1
  YDLIST%N3D = YDLIST%N3D + 1
  
  IF (YDLIST%N3D > SIZE (YDLIST%YL3D)) THEN
    CALL ABOR1 ('EXCHANGE_MS:ADD3DFL: LIST IS FULL')
  ENDIF
  
  ASSOCIATE (YL3D => YDLIST%YL3D (YDLIST%N3D))
    WRITE (YL3D%CNAME, '(A,".",I4.4)') JFLD
    YL3D%ZSP   => PSP (:,:,JFLD)
    YL3D%ZSPG  => PSPG (:,:,JFLDG)
  END ASSOCIATE

ENDDO

999 CONTINUE

IF (LHOOK) CALL DR_HOOK('EXCHANGE_MS:ADD3DFL',1,ZHOOK_HANDLE)

END SUBROUTINE

END MODULE
