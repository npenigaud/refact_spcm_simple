MODULE EXCHANGE_MS_MOD

USE GEOMETRY_MOD , ONLY : GEOMETRY
USE PARKIND1     , ONLY : JPIM, JPRB
USE YOMHOOK      , ONLY : LHOOK, DR_HOOK
USE YOMMP0       , ONLY : NPRTRV, NPRTRN, NPRCIDS, MYSETV, MYSETN, MYSETW, MYSETM, MYPROC

IMPLICIT NONE

INTEGER (KIND=JPIM), PARAMETER :: NEXCHANGE_MTOS = 111, NEXCHANGE_STOM = 222

TYPE FIELD3D
  REAL (KIND=JPRB), POINTER :: ZSP (:,:) => NULL (), ZSPG (:,:) => NULL ()
  CHARACTER (LEN=16) :: CNAME
END TYPE

TYPE FIELD2D
  REAL (KIND=JPRB), POINTER :: ZSP (:) => NULL (), ZSPG (:) => NULL ()
  CHARACTER (LEN=16) :: CNAME
  LOGICAL :: LBCAST = .FALSE.
END TYPE

INTEGER (KIND=JPIM), PARAMETER :: NFLDMAX = 100

TYPE FIELDLIST
  TYPE (FIELD3D) :: YL3D (NFLDMAX)
  INTEGER (KIND=JPIM) :: N3D = 0
  TYPE (FIELD2D) :: YL2D (NFLDMAX)
  INTEGER (KIND=JPIM) :: N2D = 0
END TYPE

ABSTRACT INTERFACE
  SUBROUTINE MESSAGE_FUN (YDGEOMETRY, LDTRANSPOSE, KSPEC2V, KPTRSV, YDLIST, KJR, PBUF_M, KPEER, KSIZE, KWHAT)
  USE PARKIND1, ONLY : JPRB, JPIM
  USE GEOMETRY_MOD, ONLY : GEOMETRY
  IMPORT :: FIELDLIST
  TYPE (GEOMETRY)    ,INTENT(IN)              :: YDGEOMETRY
  LOGICAL            ,INTENT(IN)              :: LDTRANSPOSE
  INTEGER (KIND=JPIM),INTENT(IN)              :: KSPEC2V
  INTEGER (KIND=JPIM),INTENT(IN)              :: KPTRSV (:)
  TYPE (FIELDLIST)   ,INTENT(IN)              :: YDLIST
  INTEGER(KIND=JPIM) ,INTENT(IN)              :: KJR
  REAL(KIND=JPRB)                   ,OPTIONAL :: PBUF_M(:)
  INTEGER(KIND=JPIM) ,INTENT(OUT)   ,OPTIONAL :: KPEER, KSIZE
  INTEGER(KIND=JPIM) ,INTENT(IN)              :: KWHAT
  END SUBROUTINE
END INTERFACE

INTEGER (KIND=JPIM), PARAMETER :: NPACK = 11, NUNPACK = 22, NQUERY = 33

INTEGER(KIND=JPIM), EXTERNAL :: MYSENDSET, MYRECVSET

PRIVATE
PUBLIC :: EXCHANGE_MS, NEXCHANGE_MTOS, NEXCHANGE_STOM, FIELDLIST, &
 & ADD3DF, ADD3DFL, ADD2DF, ADD2DFL,TERMINATE_LIST

CONTAINS

SUBROUTINE EXCHANGE_MS (YDGEOMETRY,LDTRANSPOSE,YDLIST, KDIR, LDFULLM)

USE YOMTAG, ONLY : MTAGMS, MTAGSM

IMPLICIT NONE

TYPE(GEOMETRY)     ,INTENT(IN) :: YDGEOMETRY
LOGICAL            ,INTENT(IN) :: LDTRANSPOSE
TYPE (FIELDLIST)   ,INTENT(IN) :: YDLIST
INTEGER(KIND=JPIM) ,INTENT(IN) :: KDIR
LOGICAL, OPTIONAL  ,INTENT(IN) :: LDFULLM

#include "abor1.intfb.h"

INTEGER(KIND=JPIM) :: IPTRSV  (NPRTRV+1)
INTEGER(KIND=JPIM) :: ISPEC2V, JR
LOGICAL :: LLFULLM

INTEGER(KIND=JPIM) :: ISIZEMAX_M, INPROC_M, INRANK_M (NPRTRV-1), IPEER_M (NPRTRV-1), ISIZE_M (NPRTRV-1)
INTEGER(KIND=JPIM) :: ISIZEMAX_S, INPROC_S, INRANK_S (NPRTRV-1), IPEER_S (NPRTRV-1), ISIZE_S (NPRTRV-1)

REAL(KIND=JPRB) :: ZHOOK_HANDLE,ZHOOK_HANDLE2

IF (LHOOK) CALL DR_HOOK('EXCHANGE_MS',0,ZHOOK_HANDLE)

ASSOCIATE(YDDIMV=>YDGEOMETRY%YRDIMV,YDMP=>YDGEOMETRY%YRMP)
ASSOCIATE(NFLEVG=>YDDIMV%NFLEVG, NFLEVL=>YDDIMV%NFLEVL, NPTRLL=>YDMP%NPTRLL, NPSP=>YDMP%NPSP, NPSURF=>YDMP%NPSURF, &
& NPTRSV=>YDMP%NPTRSV, NPTRSVF=>YDMP%NPTRSVF, NSPEC2V=>YDMP%NSPEC2V, NSPEC2VF=>YDMP%NSPEC2VF)

IF (LHOOK) CALL DR_HOOK('EXCHANGE_MS:init',0,ZHOOK_HANDLE2)

LLFULLM=.FALSE.
IF(PRESENT(LDFULLM)) LLFULLM=LDFULLM

IF (LLFULLM) THEN
  ISPEC2V=NSPEC2VF
  IPTRSV(:)=NPTRSVF(:)
ELSE
  ISPEC2V=NSPEC2V
  IPTRSV(:)=NPTRSV(:)
ENDIF
!$ACC DATA COPYIN(IPTRSV,ISPEC2V) 
!$ACC DATA PRESENT(YDGEOMETRY,YDGEOMETRY%YRDIMV,YDGEOMETRY%YRMP,YDLIST)

IF (LHOOK) CALL DR_HOOK('EXCHANGE_MS:init',1,ZHOOK_HANDLE2)


ISIZEMAX_M = 0 
ISIZEMAX_S = 0 

INPROC_M = 0 
INPROC_S = 0 
IF (LHOOK) CALL DR_HOOK('EXCHANGE_MS:tailles',0,ZHOOK_HANDLE2)

DO JR = 1, NPRTRV-1 

  CALL MESSAGE_M (YDGEOMETRY, LDTRANSPOSE, ISPEC2V, IPTRSV, YDLIST, JR, KSIZE=ISIZE_M (JR), KPEER=IPEER_M (JR), KWHAT=NQUERY)
  CALL MESSAGE_S (YDGEOMETRY, LDTRANSPOSE, ISPEC2V, IPTRSV, YDLIST, JR, KSIZE=ISIZE_S (JR), KPEER=IPEER_S (JR), KWHAT=NQUERY)

  ISIZEMAX_M = MAX (ISIZEMAX_M, ISIZE_M(JR))
  ISIZEMAX_S = MAX (ISIZEMAX_S, ISIZE_S(JR))

  IF (ISIZE_M (JR) > 0) THEN
    INPROC_M=INPROC_M+1
    INRANK_M(INPROC_M)=JR
  ENDIF

  IF (ISIZE_S (JR) > 0) THEN
    INPROC_S=INPROC_S+1
    INRANK_S(INPROC_S)=JR
  ENDIF

ENDDO

IF (LHOOK) CALL DR_HOOK('EXCHANGE_MS:tailles',1,ZHOOK_HANDLE2)

SELECT CASE (KDIR)
  CASE (NEXCHANGE_MTOS) 
    CALL EXCHANGE (YDGEOMETRY, LDTRANSPOSE,ISPEC2V, IPTRSV, YDLIST, KDIR, MTAGMS, &
                 & ISIZEMAX_M, INPROC_M, INRANK_M, IPEER_M, ISIZE_M, MESSAGE_M, &
                 & ISIZEMAX_S, INPROC_S, INRANK_S, IPEER_S, ISIZE_S, MESSAGE_S)
  CASE (NEXCHANGE_STOM)
    CALL EXCHANGE (YDGEOMETRY, LDTRANSPOSE,ISPEC2V, IPTRSV, YDLIST, KDIR, MTAGSM, &
                 & ISIZEMAX_S, INPROC_S, INRANK_S, IPEER_S, ISIZE_S, MESSAGE_S, &
                 & ISIZEMAX_M, INPROC_M, INRANK_M, IPEER_M, ISIZE_M, MESSAGE_M)
  CASE DEFAULT
    CALL ABOR1 ('EXCHANGE_MS: UNEXPECTED KDIR')
END SELECT
!$ACC END DATA
!$ACC END DATA
END ASSOCIATE
END ASSOCIATE

IF (LHOOK) CALL DR_HOOK('EXCHANGE_MS',1,ZHOOK_HANDLE)

END SUBROUTINE EXCHANGE_MS

SUBROUTINE EXCHANGE (YDGEOMETRY, LDTRANSPOSE,KSPEC2V, KPTRSV, YDLIST, KDIR, KTAG,     &
& KSIZEMAXSEND, KPROCSEND, KRANKSEND, KPEERSEND, KSIZESEND, MESSAGE_SEND, &
& KSIZEMAXRECV, KPROCRECV, KRANKRECV, KPEERRECV, KSIZERECV, MESSAGE_RECV)

USE MPL_MODULE   , ONLY : MPL_SEND, MPL_RECV, MPL_WAIT, MPL_WAITANY, JP_NON_BLOCKING_STANDARD, JP_BLOCKING_STANDARD

TYPE (GEOMETRY)   , INTENT (IN) :: YDGEOMETRY
LOGICAL           , INTENT (IN) :: LDTRANSPOSE
INTEGER(KIND=JPIM), INTENT(IN)  :: KSPEC2V
INTEGER(KIND=JPIM), INTENT(IN)  :: KPTRSV (:)
TYPE (FIELDLIST)                :: YDLIST
INTEGER(KIND=JPIM), INTENT (IN) :: KDIR, KTAG
INTEGER(KIND=JPIM), INTENT (IN) :: KSIZEMAXSEND, KPROCSEND, KRANKSEND (:), KPEERSEND (:), KSIZESEND (:)
INTEGER(KIND=JPIM), INTENT (IN) :: KSIZEMAXRECV, KPROCRECV, KRANKRECV (:), KPEERRECV (:), KSIZERECV (:)
PROCEDURE (MESSAGE_FUN) :: MESSAGE_SEND, MESSAGE_RECV

REAL(KIND=JPRB) :: ZBUFSEND (KSIZEMAXSEND,KPROCSEND)
REAL(KIND=JPRB) :: ZBUFRECV (KSIZEMAXRECV,KPROCRECV)

INTEGER(KIND=JPIM) :: ISENDREQ (KPROCSEND)
INTEGER(KIND=JPIM) :: IRECVREQ (KPROCRECV)

INTEGER(KIND=JPIM) :: I, J, JR, ISP, JVERSP, JFLD
INTEGER(KIND=JPIM) :: ILEV1, ILEV2

! Use of blocking recv in transpostions (some networks do get flooded)
! 0 = full non-blocking (default)
! 1 = immediate sends, blocking receives
INTEGER(KIND=JPIM), PARAMETER :: NSPEC_SYNC_LEVEL = 0

REAL(KIND=JPRB) :: ZHOOK_HANDLE,ZHOOK_HANDLE2

IF (LHOOK) CALL DR_HOOK('EXCHANGE_MS:EXCHANGE',0,ZHOOK_HANDLE)

ASSOCIATE(NFLEVL=>YDGEOMETRY%YRDIMV%NFLEVL, NPTRLL=>YDGEOMETRY%YRMP%NPTRLL, NPSP=>YDGEOMETRY%YRMP%NPSP)
!$ACC DATA CREATE(ZBUFSEND,ZBUFRECV) 
!$ACC DATA PRESENT(YDGEOMETRY,YDGEOMETRY%YRDIMV%NFLEVL,YDLIST,KPTRSV)
!$ACC DATA PRESENT(YDLIST,KPTRSV,NFLEVL,NPTRLL,NPSP) 
!$ACC DATA PRESENT(YDLIST%YL3D(1)%ZSPG,YDLIST%YL3D(1)%ZSP) IF(YDLIST%N3D.GE.1)
!$ACC DATA PRESENT(YDLIST%YL3D(2)%ZSPG,YDLIST%YL3D(2)%ZSP) IF(YDLIST%N3D.GE.2)
!$ACC DATA PRESENT(YDLIST%YL3D(3)%ZSPG,YDLIST%YL3D(3)%ZSP) IF(YDLIST%N3D.GE.3)
!$ACC DATA PRESENT(YDLIST%YL3D(4)%ZSPG,YDLIST%YL3D(4)%ZSP) IF(YDLIST%N3D.GE.4)
!$ACC DATA PRESENT(YDLIST%YL3D(5)%ZSPG,YDLIST%YL3D(5)%ZSP) IF(YDLIST%N3D.GE.5)
!$ACC DATA PRESENT(YDLIST%YL2D(1)%ZSP,YDLIST%YL2D(1)%LBCAST,YDLIST%YL2D(1)%ZSPG) IF(YDLIST%N2D.GE.1)

! * Recv loop .................................................

IF (NSPEC_SYNC_LEVEL == 0) THEN
  DO J=1,KPROCRECV
    JR=KRANKRECV(J)
    !$ACC HOST_DATA USE_DEVICE(ZBUFRECV(:,J))
    CALL MPL_RECV (ZBUFRECV (:,J), KSOURCE=KPEERRECV (JR), KMP_TYPE=JP_NON_BLOCKING_STANDARD,&
     & KREQUEST=IRECVREQ(J), KTAG=KTAG, CDSTRING='EXCHANGE_MS:')
    !$ACC END HOST_DATA
  ENDDO
ENDIF

! * Pack and send loop .................................................

DO J=1,KPROCSEND
  JR=KRANKSEND(J)

     IF (LHOOK) CALL DR_HOOK('EXCHANGE_MS:ms_send',0,ZHOOK_HANDLE2)
  CALL MESSAGE_SEND (YDGEOMETRY, LDTRANSPOSE, KSPEC2V, KPTRSV, YDLIST, JR, ZBUFSEND (:,J), KWHAT=NPACK)
     IF (LHOOK) CALL DR_HOOK('EXCHANGE_MS:ms_send',1,ZHOOK_HANDLE2)

  !$ACC HOST_DATA USE_DEVICE(ZBUFSEND(:,J))
  CALL MPL_SEND (ZBUFSEND (1:KSIZESEND (JR),J), KDEST=KPEERSEND (JR), KMP_TYPE=JP_NON_BLOCKING_STANDARD, &
   & KREQUEST=ISENDREQ(J), KTAG=KTAG, CDSTRING='EXCHANGE_MS:')
  !$ACC END HOST_DATA
ENDDO

! * Transpose data used on local processor .................................................
 IF (LHOOK) CALL DR_HOOK('EXCHANGE_MS:ms_self',0,ZHOOK_HANDLE2)

IF (LDTRANSPOSE) THEN
#if defined(_OPENACC)
  !$ACC PARALLEL PRIVATE(JVERSP,ISP,JFLD) DEFAULT(NONE)
  ILEV1=NPTRLL(MYSETV)
  ILEV2=ILEV1+NFLEVL-1
  !$ACC LOOP GANG VECTOR PRIVATE(JVERSP,ISP,JFLD)
#else
  ILEV1=NPTRLL(MYSETV)
  ILEV2=ILEV1+NFLEVL-1
  !$OMP PARALLEL DO SCHEDULE (STATIC) PRIVATE (JVERSP,ISP,JFLD)
#endif
  DO JVERSP = 1, KSPEC2V
    ISP=KPTRSV(MYSETV)-1+JVERSP
    DO JFLD = 1, YDLIST%N3D
      IF (KDIR == NEXCHANGE_MTOS) THEN
        YDLIST%YL3D (JFLD)%ZSPG (JVERSP,ILEV1:ILEV2) = YDLIST%YL3D (JFLD)%ZSP (1:NFLEVL,ISP)
      ELSEIF (KDIR == NEXCHANGE_STOM) THEN
        YDLIST%YL3D (JFLD)%ZSP (1:NFLEVL,ISP) = YDLIST%YL3D (JFLD)%ZSPG (JVERSP,ILEV1:ILEV2)
      ENDIF
    ENDDO

    DO JFLD = 1, YDLIST%N2D
      IF ((NPSP == 1) .OR. & 
        &  YDLIST%YL2D (JFLD)%LBCAST) THEN ! Only KDIR=NEXCHANGE_STOM (LDNEEDPS=T)
        IF (KDIR == NEXCHANGE_MTOS) THEN
          YDLIST%YL2D (JFLD)%ZSPG (JVERSP) = YDLIST%YL2D (JFLD)%ZSP (ISP)
        ELSEIF (KDIR == NEXCHANGE_STOM) THEN
          YDLIST%YL2D (JFLD)%ZSP (ISP) = YDLIST%YL2D (JFLD)%ZSPG (JVERSP) 
        ENDIF
      ENDIF
    ENDDO
  ENDDO
#if defined(_OPENACC)
  !$ACC END PARALLEL
#else
  !$OMP END PARALLEL DO
#endif

ELSE
#if defined(_OPENACC)
  !$ACC PARALLEL DEFAULT(NONE)
  ILEV1=NPTRLL(MYSETV)
  ILEV2=ILEV1+NFLEVL-1
  !$ACC LOOP GANG vector PRIVATE(JVERSP,JFLD,ISP)
#else
  ILEV1=NPTRLL(MYSETV)
  ILEV2=ILEV1+NFLEVL-1
  !$OMP PARALLEL DO SCHEDULE (STATIC) PRIVATE (JVERSP,ISP,JFLD)
#endif
  DO JVERSP = 1, KSPEC2V
    ISP=KPTRSV(MYSETV)-1+JVERSP
    DO JFLD = 1, YDLIST%N3D
      IF (KDIR == NEXCHANGE_MTOS) THEN
        YDLIST%YL3D (JFLD)%ZSPG (JVERSP,ILEV1:ILEV2) = YDLIST%YL3D (JFLD)%ZSP (ISP,1:NFLEVL)
      ELSEIF (KDIR == NEXCHANGE_STOM) THEN
        YDLIST%YL3D (JFLD)%ZSP (ISP,1:NFLEVL) = YDLIST%YL3D (JFLD)%ZSPG (JVERSP,ILEV1:ILEV2)
      ENDIF
    ENDDO

    DO JFLD = 1, YDLIST%N2D
      IF ((NPSP == 1) .OR. & 
        &  YDLIST%YL2D (JFLD)%LBCAST) THEN ! Only KDIR=NEXCHANGE_STOM (LDNEEDPS=T)
        IF (KDIR == NEXCHANGE_MTOS) THEN
          YDLIST%YL2D (JFLD)%ZSPG (JVERSP) = YDLIST%YL2D (JFLD)%ZSP (ISP)
        ELSEIF (KDIR == NEXCHANGE_STOM) THEN
          YDLIST%YL2D (JFLD)%ZSP (ISP) = YDLIST%YL2D (JFLD)%ZSPG (JVERSP) 
        ENDIF
      ENDIF
    ENDDO
  ENDDO
#if defined(_OPENACC)
  !$ACC END PARALLEL
#else
  !$OMP END PARALLEL DO
#endif

ENDIF

 IF (LHOOK) CALL DR_HOOK('EXCHANGE_MS:ms_self',1,ZHOOK_HANDLE2)

! * Recv + unpack loop .................................................

IF (NSPEC_SYNC_LEVEL == 0) THEN

  DO I=1,KPROCRECV
    CALL MPL_WAITANY (KREQUEST=IRECVREQ, KINDEX=J, CDSTRING='EXCHANGE_MS: WAIT FOR RECEIVES')
    JR=KRANKRECV (J)

  
   IF (LHOOK) CALL DR_HOOK('EXCHANGE_MS:ms_recv',0,ZHOOK_HANDLE2)

    CALL MESSAGE_RECV (YDGEOMETRY, LDTRANSPOSE, KSPEC2V, KPTRSV, YDLIST, JR, ZBUFRECV (:,J), KWHAT=NUNPACK)
  
   IF (LHOOK) CALL DR_HOOK('EXCHANGE_MS:ms_recv',1,ZHOOK_HANDLE2)

  ENDDO

  CALL MPL_WAIT (KREQUEST=ISENDREQ, CDSTRING='EXCHANGE_MS: WAIT FOR SENDS')

ELSE

  DO J=1,KPROCRECV
    JR=KRANKRECV(J)
    !$ACC HOST_DATA USE_DEVICE(ZBUFRECV(:,J))
    CALL MPL_RECV (ZBUFRECV (:,J), KSOURCE=KPEERRECV (JR), KMP_TYPE=JP_BLOCKING_STANDARD, &
     & KTAG=KTAG, CDSTRING='EXCHANGE_MS:')
    !$ACC END HOST_DATA

  IF (LHOOK) CALL DR_HOOK('EXCHANGE_MS:ms_recv',0,ZHOOK_HANDLE2)

    CALL MESSAGE_RECV (YDGEOMETRY, LDTRANSPOSE, KSPEC2V, KPTRSV, YDLIST, JR, ZBUFRECV (:,JR), KWHAT=NUNPACK)
  IF (LHOOK) CALL DR_HOOK('EXCHANGE_MS:ms_recv',1,ZHOOK_HANDLE2)


  ENDDO

ENDIF
!$ACC END DATA
!$ACC END DATA
!$ACC END DATA
!$ACC END DATA
!$ACC END DATA
!$ACC END DATA 
!$ACC END DATA
!$ACC END DATA
!$ACC END DATA

END ASSOCIATE
IF (LHOOK) CALL DR_HOOK('EXCHANGE_MS:EXCHANGE',1,ZHOOK_HANDLE)

END SUBROUTINE EXCHANGE

SUBROUTINE MESSAGE_M (YDGEOMETRY, LDTRANSPOSE, KSPEC2V, KPTRSV, YDLIST, KJR, PBUF_M, KPEER, KSIZE, KWHAT)

TYPE (GEOMETRY)    ,INTENT(IN)              :: YDGEOMETRY
LOGICAL            ,INTENT(IN)              :: LDTRANSPOSE
INTEGER(KIND=JPIM), INTENT(IN)              :: KSPEC2V
INTEGER(KIND=JPIM), INTENT(IN)              :: KPTRSV (:)
TYPE (FIELDLIST)   ,INTENT(IN)              :: YDLIST
INTEGER(KIND=JPIM) ,INTENT(IN)              :: KJR
REAL(KIND=JPRB)                   ,OPTIONAL :: PBUF_M(:)
INTEGER(KIND=JPIM) ,INTENT(OUT)   ,OPTIONAL :: KPEER, KSIZE
INTEGER(KIND=JPIM) ,INTENT(IN)              :: KWHAT

#include "set2pe.intfb.h"

INTEGER(KIND=JPIM) :: IPOS, IOFF, ILEN, ISENDSET, JFLD
INTEGER(KIND=JPIM) :: ISPE, ISPEL, ISPE1, ISPE2,ICNT,ILEV,compteur,longueur

REAL(KIND=JPRB) :: ZHOOK_HANDLE,ZHOOK_HANDLE2

IF (LHOOK) CALL DR_HOOK('EXCHANGE_MS:MESSAGE_M',0,ZHOOK_HANDLE)

ASSOCIATE(NFLEVL=>YDGEOMETRY%YRDIMV%NFLEVL, NPSP=>YDGEOMETRY%YRMP%NPSP)
!$ACC DATA PRESENT(YDGEOMETRY,YDLIST,NFLEVL,KPTRSV,NPSP,PBUF_M) 
!$ACC DATA PRESENT(YDLIST%YL3D(1)%ZSPG,YDLIST%YL3D(1)%ZSP) IF(YDLIST%N3D.GE.1)
!$ACC DATA PRESENT(YDLIST%YL3D(2)%ZSPG,YDLIST%YL3D(2)%ZSP) IF(YDLIST%N3D.GE.2)
!$ACC DATA PRESENT(YDLIST%YL3D(3)%ZSPG,YDLIST%YL3D(3)%ZSP) IF(YDLIST%N3D.GE.3)
!$ACC DATA PRESENT(YDLIST%YL3D(4)%ZSPG,YDLIST%YL3D(4)%ZSP) IF(YDLIST%N3D.GE.4)
!$ACC DATA PRESENT(YDLIST%YL3D(5)%ZSPG,YDLIST%YL3D(5)%ZSP) IF(YDLIST%N3D.GE.5)
!$ACC DATA PRESENT(YDLIST%YL2D(1)%ZSP,YDLIST%YL2D(1)%LBCAST,YDLIST%YL2D(1)%ZSPG) IF(YDLIST%N2D.GE.1)

ISENDSET=MYSENDSET(NPRTRV,MYSETV,KJR)

IF (PRESENT (KPEER)) THEN
  CALL SET2PE (KPEER, 0, 0, MYSETW, ISENDSET)
  KPEER = NPRCIDS (KPEER)
ENDIF

ISPE1=KPTRSV(ISENDSET)
ISPE2=KPTRSV(ISENDSET+1)-1
ISPEL=ISPE2-ISPE1+1 ! KSPEC2V on remote task

IOFF = 0
IF (LHOOK) CALL DR_HOOK('EXCHANGE_MS:m_m_2d',0,ZHOOK_HANDLE2)

#if defined(_OPENACC)
DO JFLD = 1, YDLIST%N2D
  IF ((NPSP == 1) .OR. &
    &  YDLIST%YL2D (JFLD)%LBCAST) THEN ! Only for KWHAT == NUNPACK (KDIR=NEXCHANGE_STOM)
    IF (KWHAT == NPACK) THEN
      !$ACC PARALLEL PRIVATE(ICNT)
      !$ACC LOOP GANG VECTOR
      DO ICNT=1,ISPEL
        PBUF_M(IOFF+ICNT)=YDLIST%YL2D(JFLD)%ZSP(ISPE1-1+ICNT)
      ENDDO
      !$ACC END PARALLEL
    ELSEIF (KWHAT == NUNPACK) THEN
      !$ACC PARALLEL PRIVATE(ICNT)
      !$ACC LOOP GANG VECTOR
      DO ICNT=1,ISPEL
        YDLIST%YL2D (JFLD)%ZSP (ISPE1-1+ICNT) = PBUF_M (IOFF+ICNT)
      ENDDO
      !$ACC END PARALLEL
    ENDIF
    IOFF = IOFF + ISPEL
  ENDIF
ENDDO
#else
DO JFLD = 1, YDLIST%N2D
  IF ((NPSP == 1) .OR. &
    &  YDLIST%YL2D (JFLD)%LBCAST) THEN ! Only for KWHAT == NUNPACK (KDIR=NEXCHANGE_STOM)
    IF (KWHAT == NPACK) THEN
        PBUF_M (IOFF+1:IOFF+ISPEL) = YDLIST%YL2D (JFLD)%ZSP (ISPE1:ISPE2) 
    ELSEIF (KWHAT == NUNPACK) THEN
        YDLIST%YL2D (JFLD)%ZSP (ISPE1:ISPE2) = PBUF_M (IOFF+1:IOFF+ISPEL)
    ENDIF
    IOFF = IOFF + ISPEL
  ENDIF
ENDDO
#endif

IF (LHOOK) CALL DR_HOOK('EXCHANGE_MS:m_m_2d',1,ZHOOK_HANDLE2)

ILEN = NFLEVL * YDLIST%N3D

IF (KWHAT /= NQUERY) THEN
  IF (LHOOK) CALL DR_HOOK('EXCHANGE_MS:m_m_3d',0,ZHOOK_HANDLE2)

  IF (LDTRANSPOSE) THEN

    !$OMP PARALLEL DO SCHEDULE(STATIC) PRIVATE (ISPE,IPOS,JFLD)
    DO ISPE = ISPE1,ISPE2
      IPOS=IOFF+(ISPE-ISPE1)*ILEN
      DO JFLD = 1, YDLIST%N3D
        IF (KWHAT == NPACK) THEN
          PBUF_M(IPOS+1:IPOS+NFLEVL) = YDLIST%YL3D (JFLD)%ZSP (1:NFLEVL,ISPE)
        ELSEIF (KWHAT == NUNPACK) THEN
          YDLIST%YL3D (JFLD)%ZSP (1:NFLEVL,ISPE) = PBUF_M(IPOS+1:IPOS+NFLEVL) 
        ENDIF
        IPOS = IPOS + NFLEVL
      ENDDO
    ENDDO
    !$OMP END PARALLEL DO

  ELSE
#if defined(_OPENACC)
    !$ACC PARALLEL DEFAULT(NONE) 
    !$ACC LOOP GANG PRIVATE(ILEV,JFLD,IPOS) COLLAPSE(3)
#else
    !$OMP PARALLEL DO SCHEDULE(STATIC) PRIVATE (ISPE,IPOS,JFLD,compteur,longueur)
#endif
    DO ILEV = 1,NFLEVL
      DO JFLD=1,YDLIST%N3D
       do compteur=ispe1,ispe2,256
        longueur=min(256,ispe2-compteur+1)
        IPOS=IOFF+ISPEL*(ILEV-1)*YDLIST%N3D+(JFLD-1)*ISPEL 
        IF (KWHAT == NPACK) THEN
          PBUF_M(IPOS+compteur-ispe1+1:IPOS+compteur-ispe1+longueur) = YDLIST%YL3D (JFLD)%ZSP (compteur:compteur+longueur-1,ILEV)
        ELSEIF (KWHAT == NUNPACK) THEN
          YDLIST%YL3D (JFLD)%ZSP (compteur:compteur+longueur-1,ILEV) =PBUF_M(IPOS+compteur-ispe1+1:IPOS+compteur-ispe1+longueur) 
        ENDIF
       enddo
      ENDDO
    ENDDO
#if defined(_OPENACC)
  !$ACC END PARALLEL
#else
!$OMP END PARALLEL DO
#endif

  ENDIF

  IF (LHOOK) CALL DR_HOOK('EXCHANGE_MS:m_m_3d',1,ZHOOK_HANDLE2)
ENDIF

IF (PRESENT (KSIZE)) KSIZE = IOFF + ISPEL * ILEN

!$ACC END DATA
!$ACC END DATA
!$ACC END DATA
!$ACC END DATA
!$ACC END DATA 
!$ACC END DATA
!$ACC END DATA

END ASSOCIATE

IF (LHOOK) CALL DR_HOOK('EXCHANGE_MS:MESSAGE_M',1,ZHOOK_HANDLE)

END SUBROUTINE MESSAGE_M 

SUBROUTINE MESSAGE_S (YDGEOMETRY, LDTRANSPOSE, KSPEC2V, KPTRSV, YDLIST, KJR, PBUF_S, KPEER, KSIZE, KWHAT)

TYPE (GEOMETRY)    ,INTENT(IN)              :: YDGEOMETRY
LOGICAL            ,INTENT(IN)              :: LDTRANSPOSE
INTEGER(KIND=JPIM), INTENT(IN)              :: KSPEC2V
INTEGER(KIND=JPIM), INTENT(IN)              :: KPTRSV (:)
TYPE (FIELDLIST)   ,INTENT(IN)              :: YDLIST
INTEGER(KIND=JPIM) ,INTENT(IN)              :: KJR
REAL(KIND=JPRB)                   ,OPTIONAL :: PBUF_S(:)
INTEGER(KIND=JPIM) ,INTENT(OUT)   ,OPTIONAL :: KPEER, KSIZE
INTEGER(KIND=JPIM) ,INTENT(IN)              :: KWHAT

#include "set2pe.intfb.h"

INTEGER(KIND=JPIM) :: ISPE, ILEVL, IPOS, ILEN, IOFF, IRECVSET, JFLD
INTEGER(KIND=JPIM) :: ILEV1, ILEV2,ICNT,ILEV

REAL(KIND=JPRB) :: ZHOOK_HANDLE,ZHOOK_HANDLE2

IF (LHOOK) CALL DR_HOOK('EXCHANGE_MS:MESSAGE_S',0,ZHOOK_HANDLE)

ASSOCIATE(YDMP=>YDGEOMETRY%YRMP)
ASSOCIATE(NPTRLL=>YDMP%NPTRLL, NPSURF=>YDMP%NPSURF)
!$ACC DATA PRESENT(YDGEOMETRY,YDLIST,KPTRSV,NPTRLL,PBUF_S) 
!$ACC DATA PRESENT(YDLIST%YL3D(1)%ZSPG,YDLIST%YL3D(1)%ZSP) IF(YDLIST%N3D.GE.1)
!$ACC DATA PRESENT(YDLIST%YL3D(2)%ZSPG,YDLIST%YL3D(2)%ZSP) IF(YDLIST%N3D.GE.2)
!$ACC DATA PRESENT(YDLIST%YL3D(3)%ZSPG,YDLIST%YL3D(3)%ZSP) IF(YDLIST%N3D.GE.3)
!$ACC DATA PRESENT(YDLIST%YL3D(4)%ZSPG,YDLIST%YL3D(4)%ZSP) IF(YDLIST%N3D.GE.4)
!$ACC DATA PRESENT(YDLIST%YL3D(5)%ZSPG,YDLIST%YL3D(5)%ZSP) IF(YDLIST%N3D.GE.5)
!$ACC DATA PRESENT(YDLIST%YL2D(1)%ZSP,YDLIST%YL2D(1)%LBCAST,YDLIST%YL2D(1)%ZSPG) if(YDLIST%N2D.GE.1)

IRECVSET=MYRECVSET(NPRTRN,MYSETN,KJR)

IF (PRESENT (KPEER)) THEN
  CALL SET2PE (KPEER, 0, 0, MYSETM, IRECVSET)
  KPEER = NPRCIDS (KPEER)
ENDIF

ILEV1=NPTRLL(IRECVSET)
ILEV2=NPTRLL(IRECVSET+1)-1
ILEVL=ILEV2-ILEV1+1 ! NFLEVL on remote task

IOFF = 0
IF (LHOOK) CALL DR_HOOK('EXCHANGE_MS:m_s_2d',0,ZHOOK_HANDLE2)

#if defined(_OPENACC)
DO JFLD = 1, YDLIST%N2D
  IF ((NPSURF (IRECVSET) == 1) .OR. &
    &  YDLIST%YL2D (JFLD)%LBCAST) THEN ! Only for KWHAT == NPACK (KDIR=NEXCHANGE_STOM)
    IF (KWHAT == NPACK) THEN
      !$ACC PARALLEL PRIVATE(ICNT)
      !$ACC LOOP GANG VECTOR
      DO ICNT=1,KSPEC2V
        PBUF_S(IOFF+ICNT)=YDLIST%YL2D(JFLD)%ZSPG(ICNT)
      ENDDO
      !$ACC END PARALLEL
    ELSEIF (KWHAT == NUNPACK) THEN
      !$ACC PARALLEL PRIVATE(ICNT)
      !$ACC LOOP GANG VECTOR
      DO ICNT=1,KSPEC2V
        YDLIST%YL2D(JFLD)%ZSPG(ICNT) = PBUF_S(IOFF+ICNT)
      ENDDO
      !$ACC END PARALLEL
    ENDIF
    IOFF = IOFF + KSPEC2V
  ENDIF
ENDDO

#else
DO JFLD = 1, YDLIST%N2D
  IF ((NPSURF (IRECVSET) == 1) .OR. &
    &  YDLIST%YL2D (JFLD)%LBCAST) THEN ! Only for KWHAT == NPACK (KDIR=NEXCHANGE_STOM)
    IF (KWHAT == NPACK) THEN
      PBUF_S(IOFF+1:IOFF+KSPEC2V) = YDLIST%YL2D (JFLD)%ZSPG (1:KSPEC2V) 
    ELSEIF (KWHAT == NUNPACK) THEN
      YDLIST%YL2D (JFLD)%ZSPG (1:KSPEC2V) = PBUF_S(IOFF+1:IOFF+KSPEC2V)
    ENDIF
    IOFF = IOFF + KSPEC2V
  ENDIF
ENDDO
#endif

IF (LHOOK) CALL DR_HOOK('EXCHANGE_MS:m_s_2d',1,ZHOOK_HANDLE2)

ILEN = ILEVL * YDLIST%N3D

IF (KWHAT /= NQUERY) THEN
  IF (LHOOK) CALL DR_HOOK('EXCHANGE_MS:m_s_3d',0,ZHOOK_HANDLE2)

  IF (LDTRANSPOSE) THEN
    !$OMP PARALLEL DO SCHEDULE(STATIC) PRIVATE(ISPE,IPOS,JFLD) 
    DO ISPE = 1, KSPEC2V
      IPOS=IOFF+ILEN*(ISPE-1)
      DO JFLD = 1, YDLIST%N3D
        IF (KWHAT == NPACK) THEN
          PBUF_S(IPOS+1:IPOS+ILEVL) = YDLIST%YL3D (JFLD)%ZSPG (ISPE,ILEV1:ILEV2) 
        ELSEIF (KWHAT == NUNPACK) THEN
          YDLIST%YL3D (JFLD)%ZSPG (ISPE,ILEV1:ILEV2) = PBUF_S(IPOS+1:IPOS+ILEVL)
        ENDIF
        IPOS = IPOS + ILEVL
      ENDDO
    ENDDO
    !$OMP END PARALLEL DO

  ELSE
#if defined(_OPENACC)
    !$ACC PARALLEL DEFAULT(NONE) 
    !$ACC LOOP GANG PRIVATE(ILEV,JFLD,IPOS) COLLAPSE(2)
#else
    !$OMP PARALLEL DO SCHEDULE(STATIC) PRIVATE(ISPE,IPOS,JFLD)
#endif
    DO ILEV= ILEV1,ILEV2
      DO JFLD = 1,YDLIST%N3D
        IPOS=IOFF+KSPEC2V*(ILEV-ILEV1)*YDLIST%N3D+(JFLD-1)*KSPEC2V 
        IF (KWHAT == NPACK) THEN
          PBUF_S(IPOS+1:IPOS+KSPEC2V) = YDLIST%YL3D (JFLD)%ZSPG (1:KSPEC2V,ILEV) 
        ELSEIF (KWHAT == NUNPACK) THEN
          YDLIST%YL3D (JFLD)%ZSPG (1:KSPEC2V,ILEV) = PBUF_S(IPOS+1:IPOS+KSPEC2V)
        ENDIF
      ENDDO
    ENDDO
#if defined(_OPENACC)
    !$ACC END PARALLEL
#else
    !$OMP END PARALLEL DO
#endif

  ENDIF

  IF (LHOOK) CALL DR_HOOK('EXCHANGE_MS:m_s_3d',1,ZHOOK_HANDLE2)
ENDIF

IF (PRESENT (KSIZE)) KSIZE = IOFF + KSPEC2V * ILEN

!$ACC END DATA
!$ACC END DATA
!$ACC END DATA
!$ACC END DATA
!$ACC END DATA 
!$ACC END DATA
!$ACC END DATA

END ASSOCIATE
END ASSOCIATE

IF (LHOOK) CALL DR_HOOK('EXCHANGE_MS:MESSAGE_S',1,ZHOOK_HANDLE)

END SUBROUTINE MESSAGE_S

SUBROUTINE ADD2DF (YDLIST, PSP, PSPG, CDNAME, LDBCAST)

TYPE (FIELDLIST)                                 :: YDLIST
REAL (KIND=JPRB)               ,OPTIONAL ,TARGET :: PSP (:), PSPG (:)
CHARACTER(LEN=*)  ,INTENT(IN)                    :: CDNAME
LOGICAL           ,INTENT(IN)  ,OPTIONAL         :: LDBCAST

REAL(KIND=JPRB) :: ZHOOK_HANDLE

IF (LHOOK) CALL DR_HOOK('EXCHANGE_MS:ADD2DF',0,ZHOOK_HANDLE)

IF (.NOT. PRESENT (PSP)) GOTO 999

IF (PRESENT(PSP) .NEQV. PRESENT (PSPG)) THEN
  CALL ABOR1('EXCHANGE_MS: '//TRIM (CDNAME)//' AND '//TRIM (CDNAME)//'G HAVE TO BE BOTH PRESENT')  
ENDIF

YDLIST%N2D = YDLIST%N2D + 1
!$ACC UPDATE DEVICE(YDLIST%N2D)

IF (YDLIST%N2D > SIZE (YDLIST%YL2D)) THEN
  CALL ABOR1 ('EXCHANGE_MS:ADD2DF: LIST IS FULL')
ENDIF

ASSOCIATE (YL2D => YDLIST%YL2D (YDLIST%N2D))
  YL2D%CNAME = CDNAME
  YL2D%ZSP   => PSP
  YL2D%ZSPG  => PSPG
  IF (PRESENT (LDBCAST)) YL2D%LBCAST = LDBCAST
  !$ACC ENTER DATA COPYIN(YL2D) ATTACH(YL2D%ZSP,YL2D%ZSPG)
  !$ACC UPDATE DEVICE(YL2D%CNAME,YL2D%LBCAST)
END ASSOCIATE

999 CONTINUE

IF (LHOOK) CALL DR_HOOK('EXCHANGE_MS:ADD2DF',1,ZHOOK_HANDLE)

END SUBROUTINE

SUBROUTINE ADD3DF (YDLIST, PSP, PSPG, CDNAME)

TYPE (FIELDLIST)                                :: YDLIST
REAL (KIND=JPRB)              ,OPTIONAL ,TARGET :: PSP (:,:), PSPG (:,:)
CHARACTER(LEN=*) ,INTENT(IN)                    :: CDNAME

REAL(KIND=JPRB) :: ZHOOK_HANDLE

IF (LHOOK) CALL DR_HOOK('EXCHANGE_MS:ADD3DF',0,ZHOOK_HANDLE)

IF (.NOT. PRESENT (PSP)) GOTO 999

IF (PRESENT(PSP) .NEQV. PRESENT (PSPG)) THEN
  CALL ABOR1('EXCHANGE_MS: '//TRIM (CDNAME)//' AND '//TRIM (CDNAME)//'G HAVE TO BE BOTH PRESENT')  
ENDIF

YDLIST%N3D = YDLIST%N3D + 1
!$ACC UPDATE DEVICE(YDLIST%N3D)
IF (YDLIST%N3D > SIZE (YDLIST%YL3D)) THEN
  CALL ABOR1 ('EXCHANGE_MS:ADD3DF: LIST IS FULL')
ENDIF

ASSOCIATE (YL3D => YDLIST%YL3D (YDLIST%N3D))
  YL3D%CNAME = CDNAME
  YL3D%ZSP   => PSP
  YL3D%ZSPG  => PSPG
  !$ACC ENTER DATA COPYIN(YL3D) ATTACH(YL3D%ZSP,YL3D%ZSPG)
  !$ACC UPDATE DEVICE(YL3D%CNAME)
END ASSOCIATE

999 CONTINUE

IF (LHOOK) CALL DR_HOOK('EXCHANGE_MS:ADD3DF',1,ZHOOK_HANDLE)

END SUBROUTINE

SUBROUTINE ADD2DFL (YDLIST, PSP, PSPG, CDNAME, LDMASK)

TYPE (FIELDLIST)                                :: YDLIST
REAL (KIND=JPRB)              ,OPTIONAL, TARGET :: PSP (:,:), PSPG (:,:)
CHARACTER(LEN=*) ,INTENT(IN)                    :: CDNAME
LOGICAL          ,INTENT(IN)  ,OPTIONAL         :: LDMASK(:)

INTEGER (KIND=JPIM) :: JFLD, JFLDG
CHARACTER (LEN=16) :: CLNAME

REAL(KIND=JPRB) :: ZHOOK_HANDLE

IF (LHOOK) CALL DR_HOOK('EXCHANGE_MS:ADD2DFL',0,ZHOOK_HANDLE)

IF (.NOT. PRESENT (PSP)) GOTO 999

IF (PRESENT(PSP) .NEQV. PRESENT (PSPG)) THEN
  CALL ABOR1('EXCHANGE_MS:ADD2DFL: '//TRIM (CDNAME)//' AND '//TRIM (CDNAME)//'G HAVE TO BE BOTH PRESENT')  
ENDIF

IF (PRESENT (LDMASK)) THEN
  IF (SIZE (LDMASK) /= SIZE (PSP, 2)) THEN
    CALL ABOR1('EXCHANGE_MS:ADD2DFL: DIMENSION MISMATCH FOR '//TRIM (CDNAME))
  ENDIF
  IF (COUNT (LDMASK) /= SIZE (PSPG, 2)) THEN
    CALL ABOR1('EXCHANGE_MS:ADD2DFL: DIMENSION MISMATCH FOR '//TRIM (CDNAME))
  ENDIF
ELSE
  IF (SIZE (PSPG, 2) /= SIZE (PSP, 2)) THEN
    CALL ABOR1('EXCHANGE_MS:ADD2DFL: DIMENSION MISMATCH FOR '//TRIM (CDNAME))
  ENDIF
ENDIF

JFLDG = 0
DO JFLD = 1, SIZE (PSP, 2)

  IF (PRESENT (LDMASK)) THEN
    IF (.NOT. LDMASK (JFLD)) CYCLE
  ENDIF

  JFLDG = JFLDG + 1
  YDLIST%N2D = YDLIST%N2D + 1
  !$ACC UPDATE DEVICE(YDLIST%N2D)
  IF (YDLIST%N2D > SIZE (YDLIST%YL2D)) THEN
    CALL ABOR1 ('EXCHANGE_MS:ADD2DFL: LIST IS FULL')
  ENDIF
  
  ASSOCIATE (YL2D => YDLIST%YL2D (YDLIST%N2D))
    WRITE (YL2D%CNAME, '(A,".",I4.4)') JFLD
    YL2D%ZSP   => PSP (:,JFLD)
    YL2D%ZSPG  => PSPG (:,JFLDG)
    !$ACC ENTER DATA COPYIN(YL2D) ATTACH(YL2D%ZSP,YL2D%ZSPG)
    !$ACC UPDATE DEVICE(YL2D%CNAME)
  END ASSOCIATE

ENDDO

999 CONTINUE

IF (LHOOK) CALL DR_HOOK('EXCHANGE_MS:ADD2DFL',1,ZHOOK_HANDLE)

END SUBROUTINE

SUBROUTINE ADD3DFL (YDLIST, PSP, PSPG, CDNAME, LDMASK)

TYPE (FIELDLIST)                                  :: YDLIST
REAL (KIND=JPRB)                ,OPTIONAL, TARGET :: PSP (:,:,:), PSPG (:,:,:)
CHARACTER(LEN=*) ,INTENT(IN)                      :: CDNAME
LOGICAL          ,INTENT(IN)    ,OPTIONAL         :: LDMASK(:)

INTEGER (KIND=JPIM) :: JFLD, JFLDG
CHARACTER (LEN=16) :: CLNAME

REAL(KIND=JPRB) :: ZHOOK_HANDLE

IF (LHOOK) CALL DR_HOOK('EXCHANGE_MS:ADD3DFL',0,ZHOOK_HANDLE)

IF (.NOT. PRESENT (PSP)) GOTO 999

IF (PRESENT(PSP) .NEQV. PRESENT (PSPG)) THEN
  CALL ABOR1('EXCHANGE_MS:ADD3DFL: '//TRIM (CDNAME)//' AND '//TRIM (CDNAME)//'G HAVE TO BE BOTH PRESENT')  
ENDIF

IF (PRESENT (LDMASK)) THEN
  IF (SIZE (LDMASK) /= SIZE (PSP, 3)) THEN
    CALL ABOR1('EXCHANGE_MS:ADD3DFL: DIMENSION MISMATCH FOR '//TRIM (CDNAME))
  ENDIF
  IF (COUNT (LDMASK) /= SIZE (PSPG, 3)) THEN
    CALL ABOR1('EXCHANGE_MS:ADD3DFL: DIMENSION MISMATCH FOR '//TRIM (CDNAME))
  ENDIF
ELSE
  IF (SIZE (PSPG, 3) /= SIZE (PSP, 3)) THEN
    CALL ABOR1('EXCHANGE_MS:ADD3DFL: DIMENSION MISMATCH FOR '//TRIM (CDNAME))
  ENDIF
ENDIF

JFLDG = 0
DO JFLD = 1, SIZE (PSP, 3)

  IF (PRESENT (LDMASK)) THEN
    IF (.NOT. LDMASK (JFLD)) CYCLE
  ENDIF

  JFLDG = JFLDG + 1
  YDLIST%N3D = YDLIST%N3D + 1
  !$ACC UPDATE DEVICE(YDLIST%N3D)
  IF (YDLIST%N3D > SIZE (YDLIST%YL3D)) THEN
    CALL ABOR1 ('EXCHANGE_MS:ADD3DFL: LIST IS FULL')
  ENDIF
  
  ASSOCIATE (YL3D => YDLIST%YL3D (YDLIST%N3D))
    WRITE (YL3D%CNAME, '(A,".",I4.4)') JFLD
    YL3D%ZSP   => PSP (:,:,JFLD)
    YL3D%ZSPG  => PSPG (:,:,JFLDG)
    !$ACC ENTER DATA COPYIN(YL3D) ATTACH(YL3D%ZSP,YL3D%ZSPG)
    !$ACC UPDATE DEVICE(YL3D%CNAME)
  END ASSOCIATE

ENDDO

999 CONTINUE

IF (LHOOK) CALL DR_HOOK('EXCHANGE_MS:ADD3DFL',1,ZHOOK_HANDLE)

END SUBROUTINE

SUBROUTINE TERMINATE_LIST (YDLIST)

TYPE (FIELDLIST)             :: YDLIST

INTEGER (KIND=JPIM)          :: JFLD
REAL(KIND=JPRB)              :: ZHOOK_HANDLE

IF (LHOOK) CALL DR_HOOK('EXCHANGE_MS:TERMINATE_LIST',0,ZHOOK_HANDLE)

DO JFLD=YDLIST%N2D,1
!$ACC EXIT DATA DETACH(YDLIST%YL2D(JFLD)%ZSP)
!$ACC EXIT DATA DETACH(YDLIST%YL2D(JFLD)%ZSPG)
!$ACC EXIT DATA DELETE(YDLIST%YL2D(JFLD)%ZSP)
!$ACC EXIT DATA DELETE(YDLIST%YL2D(JFLD)%ZSPG)
ENDDO
DO JFLD=YDLIST%N3D,1
!$ACC EXIT DATA DETACH(YDLIST%YL3D(JFLD)%ZSP)
!$ACC EXIT DATA DETACH(YDLIST%YL3D(JFLD)%ZSPG)
!$ACC EXIT DATA DELETE(YDLIST%YL3D(JFLD)%ZSP)
!$ACC EXIT DATA DELETE(YDLIST%YL3D(JFLD)%ZSPG)
ENDDO
!$ACC EXIT DATA DELETE(YDLIST)

IF (LHOOK) CALL DR_HOOK('EXCHANGE_MS:TERMINATE_LIST',1,ZHOOK_HANDLE)

END SUBROUTINE

END MODULE
