PROGRAM SPCM

USE XRD_GETOPTIONS
USE TYPE_MODEL         , ONLY : MODEL
USE GEOMETRY_MOD       , ONLY : GEOMETRY
USE PARKIND1           , ONLY : JPIM, JPRB
USE YOMHOOK            , ONLY : LHOOK, DR_HOOK, JPHOOK
USE MPL_MPIF           , ONLY : MPI_COMM_WORLD, MPI_THREAD_MULTIPLE, MPI_THREAD_SINGLE, MPI_WTIME
USE MPL_MODULE         , ONLY : MPL_INIT, MPL_END
USE MPL_BARRIER_MOD    , ONLY : MPL_BARRIER

USE UTIL_MODEL_MOD
USE UTIL_GEOMETRY_MOD
USE UTIL_YOMMP0_MOD, ONLY : LOAD_YOMMP0
USE YOMMP0, ONLY          : MYSETV,MYSETN,MYSETW 

#if defined(_OPENACC)
USE CUBLAS
#endif

IMPLICIT NONE

TYPE(GEOMETRY)      :: YDGEOMETRY
TYPE(MODEL)         :: YDMODEL

REAL(KIND=JPRB), ALLOCATABLE :: PSPSP (:)
REAL(KIND=JPRB), ALLOCATABLE :: PSPVOR(:,:)
REAL(KIND=JPRB), ALLOCATABLE :: PSPDIV(:,:)
REAL(KIND=JPRB), ALLOCATABLE :: PSPT  (:,:)
REAL(KIND=JPRB), ALLOCATABLE :: PSPSPD(:,:)
REAL(KIND=JPRB), ALLOCATABLE :: PSPSVD(:,:)

REAL(KIND=JPRB), ALLOCATABLE :: PSPSP2 (:)
REAL(KIND=JPRB), ALLOCATABLE :: PSPVOR2(:,:)
REAL(KIND=JPRB), ALLOCATABLE :: PSPDIV2(:,:)
REAL(KIND=JPRB), ALLOCATABLE :: PSPT2  (:,:)
REAL(KIND=JPRB), ALLOCATABLE :: PSPSPD2(:,:)
REAL(KIND=JPRB), ALLOCATABLE :: PSPSVD2(:,:)

REAL(KIND=JPRB), ALLOCATABLE :: ZSPSP (:)
REAL(KIND=JPRB), ALLOCATABLE :: ZSPVOR(:,:)
REAL(KIND=JPRB), ALLOCATABLE :: ZSPDIV(:,:)
REAL(KIND=JPRB), ALLOCATABLE :: ZSPT  (:,:)
REAL(KIND=JPRB), ALLOCATABLE :: ZSPSPD(:,:)
REAL(KIND=JPRB), ALLOCATABLE :: ZSPSVD(:,:)

INTEGER (KIND=JPIM) :: MYPROC
INTEGER (KIND=JPIM), ALLOCATABLE :: NLOENG (:)

#include "spcm_simple.intfb.h"
#include "abor1.intfb.h"

INTEGER (KIND=JPIM) :: JSP, JLEV, JLON

INTEGER :: ILUN, IERR
INTEGER :: IREQUIRED, IPROVIDED
INTEGER :: IPRINTLEV
CHARACTER (LEN=64) :: CLFILE, CLPROC, CLCASE
LOGICAL :: LLVERBOSE, LLWRITEGRIB1, LLWRITETEXT1, LLWRITEGRIB2, LLWRITETEXT2, LLSTATGP, LLSTATSP

REAL(KIND=JPHOOK)  :: ZHOOK_HANDLE, ZHOOK_HANDLE2
INTEGER            :: JCNTREP,JCNTREP2
#define repetitif 1
call flush(0)

CALL INITOPTIONS
CALL GETOPTION ("--verbose", LLVERBOSE)
CALL GETOPTION ("--write-grib-1", LLWRITEGRIB1)
CALL GETOPTION ("--write-text-1", LLWRITETEXT1)
CALL GETOPTION ("--write-grib-2", LLWRITEGRIB2)
CALL GETOPTION ("--write-text-2", LLWRITETEXT2)
CALL GETOPTION ("--stat-gp", LLSTATGP)
CALL GETOPTION ("--stat-sp", LLSTATSP)
CALL GETOPTION ("--case", CLCASE, MND=.TRUE.)
CALL CHECKOPTIONS

IPRINTLEV=0
IF (LLVERBOSE) IPRINTLEV=2

IREQUIRED = MPI_THREAD_MULTIPLE
IPROVIDED = MPI_THREAD_SINGLE
CALL MPI_INIT_THREAD (IREQUIRED, IPROVIDED, IERR)
IF (IERR /= 0) CALL ABOR1 ('MAIN: MPI_INIT_THREAD FAILED')

CALL MPI_COMM_RANK (MPI_COMM_WORLD, MYPROC, IERR)
MYPROC = MYPROC + 1

ILUN = 77

CALL MPL_INIT ()

ILUN = 77

CALL SETUP

#if defined(_OPENACC)
CALL INITIALISEGPU(MYPROC-1)
#endif

WRITE (CLPROC, '(I4.4)') MYPROC
CLFILE = 'SPCM_SIMPLE.IN.'//TRIM (CLPROC)

OPEN (ILUN, FILE=TRIM (CLCASE)//'/'//TRIM (CLFILE), FORM='UNFORMATTED')

CALL LOAD_YOMMP0 (ILUN)
!$acc update device(MYSETV,MYSETN,MYSETW)
CALL LOAD (ILUN, YDMODEL)
CALL LOAD (ILUN, YDGEOMETRY)

ALLOCATE (PSPSP (YDGEOMETRY%YRDIM%NSPEC2))
ALLOCATE (PSPVOR(YDGEOMETRY%YRDIMV%NFLEVL,YDGEOMETRY%YRDIM%NSPEC2))
ALLOCATE (PSPDIV(YDGEOMETRY%YRDIMV%NFLEVL,YDGEOMETRY%YRDIM%NSPEC2))
ALLOCATE (PSPT  (YDGEOMETRY%YRDIMV%NFLEVL,YDGEOMETRY%YRDIM%NSPEC2))
ALLOCATE (PSPSPD(YDGEOMETRY%YRDIMV%NFLEVL,YDGEOMETRY%YRDIM%NSPEC2))
ALLOCATE (PSPSVD(YDGEOMETRY%YRDIMV%NFLEVL,YDGEOMETRY%YRDIM%NSPEC2))

ALLOCATE (PSPSP2 (YDGEOMETRY%YRDIM%NSPEC2))
ALLOCATE (PSPVOR2(YDGEOMETRY%YRDIMV%NFLEVL,YDGEOMETRY%YRDIM%NSPEC2))
ALLOCATE (PSPDIV2(YDGEOMETRY%YRDIMV%NFLEVL,YDGEOMETRY%YRDIM%NSPEC2))
ALLOCATE (PSPT2  (YDGEOMETRY%YRDIMV%NFLEVL,YDGEOMETRY%YRDIM%NSPEC2))
ALLOCATE (PSPSPD2(YDGEOMETRY%YRDIMV%NFLEVL,YDGEOMETRY%YRDIM%NSPEC2))
ALLOCATE (PSPSVD2(YDGEOMETRY%YRDIMV%NFLEVL,YDGEOMETRY%YRDIM%NSPEC2))

READ (ILUN) PSPSP 
READ (ILUN) PSPVOR
READ (ILUN) PSPDIV
READ (ILUN) PSPT  
READ (ILUN) PSPSPD
READ (ILUN) PSPSVD

PSPSP2(:)=PSPSP(:)
PSPVOR2(:,:)=PSPVOR(:,:)
PSPDIV2(:,:)=PSPDIV(:,:)
PSPT2(:,:)=PSPT(:,:)
PSPSPD2(:,:)=PSPSPD(:,:)
PSPSVD2(:,:)=PSPSVD(:,:)

CLOSE (ILUN)

IF (LLWRITETEXT1) CALL WRTEXT (PSPT, 'PSPT-1')
IF (LLWRITEGRIB1) CALL WRGRIB (PSPT, 'PSPT-1')

#if defined(_OPENACC)
!!dummy operations 
  call copy(ydmodel)
  call copy(ydgeometry)
  associate(simi=>ydmodel%yrml_dyn%yrdyn%simi,nflevg=>ydgeometry%yrdimv%nflevg)
  !$acc data copy(PSPDIV2)
  do JCNTREP=1,3
    !$acc host_data use_device(simi,PSPDIV2)
    call cublasDgemm('N','N',nflevg,nflevg,nflevg,1.0_JPRB,&
        &SIMI,nflevg,simi,nflevg,0.0_JPRB,PSPDIV2(1,1),nflevg)
    !$acc end host_data
  enddo
  !$acc end data
  end associate
  call wipe(ydgeometry)
  call wipe(ydmodel)

PSPSP2(:)=PSPSP(:)
PSPVOR2(:,:)=PSPVOR(:,:)
PSPDIV2(:,:)=PSPDIV(:,:)
PSPT2(:,:)=PSPT(:,:)
PSPSPD2(:,:)=PSPSPD(:,:)
PSPSVD2(:,:)=PSPSVD(:,:)
#endif

IF (LHOOK) CALL DR_HOOK('SPCM',0,zhook_handle)

#if defined(_OPENACC)
IF (LHOOK) CALL DR_HOOK('SPCM_transferts1',0,ZHOOK_HANDLE2)
CALL COPY(YDMODEL)
CALL COPY(YDGEOMETRY)
IF (LHOOK) CALL DR_HOOK('SPCM_transferts1',1,ZHOOK_HANDLE2)
#endif

#if repetitif
do JCNTREP2=1,20
IF (LHOOK) CALL DR_HOOK('SPCM_repetitif',0,ZHOOK_HANDLE2)
PSPSP(:)=PSPSP2(:)
PSPVOR(:,:)=PSPVOR2(:,:)
PSPDIV(:,:)=PSPDIV2(:,:)
PSPT(:,:)=PSPT2(:,:)
PSPSPD(:,:)=PSPSPD2(:,:)
PSPSVD(:,:)=PSPSVD2(:,:)
IF (LHOOK) CALL DR_HOOK('SPCM_repetitif',1,ZHOOK_HANDLE2)
#endif

CALL SPCM_SIMPLE (YDGEOMETRY,YDMODEL,PSPSP,PSPVOR,PSPDIV,PSPT,PSPSPD,PSPSVD)

#if repetitif
enddo !JCNTREP2
#endif

#if defined(_OPENACC)
IF (LHOOK) CALL DR_HOOK('SPCM_transferts2',0,ZHOOK_HANDLE2)
CALL WIPE(YDGEOMETRY)
CALL WIPE(YDMODEL)
IF (LHOOK) CALL DR_HOOK('SPCM_transferts2',1,ZHOOK_HANDLE2)
#endif

IF (LHOOK) CALL DR_HOOK('SPCM',1,ZHOOK_HANDLE)

ILUN = 77

WRITE (CLPROC, '(I4.4)') MYPROC

CLFILE = 'SPCM_SIMPLE.OUT.'//TRIM (CLPROC)

OPEN (ILUN, FILE=TRIM (CLCASE)//'/'//TRIM (CLFILE), FORM='UNFORMATTED')

ALLOCATE (ZSPSP (YDGEOMETRY%YRDIM%NSPEC2))
ALLOCATE (ZSPVOR(YDGEOMETRY%YRDIMV%NFLEVL,YDGEOMETRY%YRDIM%NSPEC2))
ALLOCATE (ZSPDIV(YDGEOMETRY%YRDIMV%NFLEVL,YDGEOMETRY%YRDIM%NSPEC2))
ALLOCATE (ZSPT  (YDGEOMETRY%YRDIMV%NFLEVL,YDGEOMETRY%YRDIM%NSPEC2))
ALLOCATE (ZSPSPD(YDGEOMETRY%YRDIMV%NFLEVL,YDGEOMETRY%YRDIM%NSPEC2))
ALLOCATE (ZSPSVD(YDGEOMETRY%YRDIMV%NFLEVL,YDGEOMETRY%YRDIM%NSPEC2))

READ (ILUN) ZSPSP 
READ (ILUN) ZSPVOR
READ (ILUN) ZSPDIV
READ (ILUN) ZSPT  
READ (ILUN) ZSPSPD
READ (ILUN) ZSPSVD

CLOSE (ILUN)


IF (LLSTATSP) THEN
  CALL STATSP ('PSPT',   PSPT,   ZSPT  )
  CALL STATSP ('PSPVOR', PSPVOR, ZSPVOR)
  CALL STATSP ('PSPDIV', PSPDIV, ZSPDIV)
  CALL STATSP ('PSPSPD', PSPSPD, ZSPSPD)
  CALL STATSP ('PSPSVD', PSPSVD, ZSPSVD)
ENDIF

IF (.FALSE.) THEN

PRINT *, " SP "
DO JSP = 1, YDGEOMETRY%YRDIM%NSPEC2, 10
  WRITE (*, '(3E30.20)') PSPSP (JSP), ZSPSP (JSP), PSPSP (JSP) - ZSPSP (JSP)
ENDDO

PRINT *, " T "
DO JLEV = 1, YDGEOMETRY%YRDIMV%NFLEVL
  PRINT *, " JLEV = ", JLEV
  DO JSP = 1, YDGEOMETRY%YRDIM%NSPEC2, 10
    WRITE (*, '(3E30.20)') PSPT (JLEV,JSP), ZSPT (JLEV,JSP), PSPT (JLEV,JSP) - ZSPT (JLEV,JSP)
  ENDDO
ENDDO

ENDIF

IF (LLWRITETEXT2) CALL WRTEXT (PSPT, 'PSPT-2')
IF (LLWRITEGRIB2) CALL WRGRIB (PSPT, 'PSPT-2')

IF (LLSTATGP) THEN
  CALL STATGP ('PSPT',   PSPT,   ZSPT  )
  CALL STATGP ('PSPVOR', PSPVOR, ZSPVOR)
  CALL STATGP ('PSPDIV', PSPDIV, ZSPDIV)
  CALL STATGP ('PSPSPD', PSPSPD, ZSPSPD)
  CALL STATGP ('PSPSVD', PSPSVD, ZSPSVD)
ENDIF

999 CONTINUE

CALL FLUSH (0)
CALL FLUSH (6)
CALL MPL_BARRIER ()

CALL MPL_END ()

CONTAINS

#if defined(_OPENACC)
SUBROUTINE INITIALISEGPU(KRANK)
USE OPENACC
IMPLICIT NONE
INTEGER, INTENT(IN)                   :: KRANK
INTEGER                               :: IDEV

!!integer           :: namelength,ierr
!!character (len=MPL_MAX_PROCESSOR_NAME), allocatable :: hosts(:)
!!character (len=MPI_MAX_PROCESSOR_NAME)              :: hostname

!!print *, mpl_node(:)  !!ranks de 1 Ã  8 apparement
!!call mpi_get_processor_name(hostname,namelength,ierr) !!trois lignes suivantes affichent le nom de la machine
!!print *,"nom :",hostname
!!print *,"statut ope:",ierr

IDEV=MOD(KRANK,4)

CALL ACC_SET_DEVICE_NUM(IDEV,ACC_DEVICE_NVIDIA)
CALL ACC_INIT(ACC_DEVICE_NVIDIA)
PRINT *,"rank ",KRANK," uses device number ",IDEV

END SUBROUTINE INITIALISEGPU
#endif

SUBROUTINE STATSP (CDNAME, PSPL1, PSPL2)

CHARACTER (LEN=*), INTENT (IN) :: CDNAME
REAL (KIND=JPRB),  INTENT (IN) :: PSPL1 (YDGEOMETRY%YRDIMV%NFLEVL,YDGEOMETRY%YRDIM%NSPEC2)
REAL (KIND=JPRB),  INTENT (IN) :: PSPL2 (YDGEOMETRY%YRDIMV%NFLEVL,YDGEOMETRY%YRDIM%NSPEC2)

#include "gath_spec.h"

REAL (KIND=JPRB), ALLOCATABLE :: ZSPG1 (:,:)
REAL (KIND=JPRB), ALLOCATABLE :: ZSPG2 (:,:)
INTEGER (KIND=JPIM) :: JLEV, JLON
INTEGER (KIND=JPIM), ALLOCATABLE :: ITO (:)
INTEGER (KIND=JPIM), ALLOCATABLE :: IVSET (:)
INTEGER (KIND=JPIM) :: ICOUNT, JSP

ALLOCATE (ITO (YDGEOMETRY%YRDIMV%NFLEVG))
ITO = 1

ALLOCATE (IVSET (YDGEOMETRY%YRDIMV%NFLEVG))
IVSET = YDGEOMETRY%YRMP%NBSETLEV


IF (MYPROC == 1) THEN
  ALLOCATE (ZSPG1 (YDGEOMETRY%YRDIMV%NFLEVG,YDGEOMETRY%YRDIM%NSPEC2G))
  ALLOCATE (ZSPG2 (YDGEOMETRY%YRDIMV%NFLEVG,YDGEOMETRY%YRDIM%NSPEC2G))
  CALL GATH_SPEC (KFGATHG=YDGEOMETRY%YRDIMV%NFLEVG, KVSET=IVSET, KTO=ITO, PSPEC=PSPL1, LDZA0IP=.TRUE., PSPECG=ZSPG1)
  CALL GATH_SPEC (KFGATHG=YDGEOMETRY%YRDIMV%NFLEVG, KVSET=IVSET, KTO=ITO, PSPEC=PSPL2, LDZA0IP=.TRUE., PSPECG=ZSPG2)
ELSE                                                         
  CALL GATH_SPEC (KFGATHG=YDGEOMETRY%YRDIMV%NFLEVG, KVSET=IVSET, KTO=ITO, PSPEC=PSPL1, LDZA0IP=.TRUE.)
  CALL GATH_SPEC (KFGATHG=YDGEOMETRY%YRDIMV%NFLEVG, KVSET=IVSET, KTO=ITO, PSPEC=PSPL2, LDZA0IP=.TRUE.)
ENDIF

IF (MYPROC == 1) THEN
  WRITE (*, '(A16," ",A6," ",A30," ",A30," ",A6)') "NAME", "JLEV", "MEAN", "MEANDIFF", "COUNT"
  DO JLEV = 1, YDGEOMETRY%YRDIMV%NFLEVG
    WRITE (*, '(A16," ",I6," ",E30.20," ",E30.20," ",I6.6)') CDNAME, JLEV, ZSPG1 (JLEV, 1), ZSPG1 (JLEV, 1) - ZSPG2 (JLEV, 1), COUNT (ZSPG1 (JLEV, :) /= ZSPG2 (JLEV, :))
    ICOUNT = 0
    DO JSP = 1, YDGEOMETRY%YRDIM%NSPEC2G
      IF (ZSPG1 (JLEV, JSP) /= ZSPG2 (JLEV, JSP)) THEN
        WRITE (*, '(I6," ",3E30.20)') JSP, ZSPG1 (JLEV, JSP), ZSPG2 (JLEV, JSP), ZSPG1 (JLEV, JSP) - ZSPG2 (JLEV, JSP)
        ICOUNT = ICOUNT + 1
        IF (ICOUNT == 10) THEN
          PRINT *, '...'
          EXIT
        ENDIF
      ENDIF
    ENDDO
  ENDDO
ENDIF


END SUBROUTINE

SUBROUTINE STATGP (CDNAME, PSPL1, PSPL2)

CHARACTER (LEN=*), INTENT (IN) :: CDNAME
REAL (KIND=JPRB),  INTENT (IN) :: PSPL1 (YDGEOMETRY%YRDIMV%NFLEVL,YDGEOMETRY%YRDIM%NSPEC2)
REAL (KIND=JPRB),  INTENT (IN) :: PSPL2 (YDGEOMETRY%YRDIMV%NFLEVL,YDGEOMETRY%YRDIM%NSPEC2)

#include "gath_grid.h"

REAL (KIND=JPRB) :: ZGPL1 (YDGEOMETRY%YRGEM%NGPTOT,YDGEOMETRY%YRDIMV%NFLEVG,1)
REAL (KIND=JPRB) :: ZGPL2 (YDGEOMETRY%YRGEM%NGPTOT,YDGEOMETRY%YRDIMV%NFLEVG,1)
REAL (KIND=JPRB), ALLOCATABLE :: ZGPG1 (:,:)
REAL (KIND=JPRB), ALLOCATABLE :: ZGPG2 (:,:)
INTEGER (KIND=JPIM) :: JLEV, JLON
INTEGER (KIND=JPIM), ALLOCATABLE :: ITO (:)

CALL SP2GP (PSPL1, ZGPL1)
CALL SP2GP (PSPL2, ZGPL2)

ALLOCATE (ITO (YDGEOMETRY%YRDIMV%NFLEVG))
ITO = 1

IF (MYPROC == 1) THEN
  ALLOCATE (ZGPG1 (YDGEOMETRY%YRGEM%NGPTOTG, YDGEOMETRY%YRDIMV%NFLEVG))
  ALLOCATE (ZGPG2 (YDGEOMETRY%YRGEM%NGPTOTG, YDGEOMETRY%YRDIMV%NFLEVG))
  CALL GATH_GRID (KFGATHG=YDGEOMETRY%YRDIMV%NFLEVG, KTO=ITO, PGP=ZGPL1, PGPG=ZGPG1)
  CALL GATH_GRID (KFGATHG=YDGEOMETRY%YRDIMV%NFLEVG, KTO=ITO, PGP=ZGPL2, PGPG=ZGPG2)
ELSE
  CALL GATH_GRID (KFGATHG=YDGEOMETRY%YRDIMV%NFLEVG, KTO=ITO, PGP=ZGPL1)
  CALL GATH_GRID (KFGATHG=YDGEOMETRY%YRDIMV%NFLEVG, KTO=ITO, PGP=ZGPL2)
ENDIF

IF (MYPROC == 1) THEN
  WRITE (*, '(A16," ",A6," ",3A30)') "NAME", "JLEV", "MAX", "MIN", "RMS"
  DO JLEV = 1, YDGEOMETRY%YRDIMV%NFLEVG
!    WRITE (*, '(A16," ",I6," ",2E30.20," ",I6)') CDNAME, JLEV, ZGPG1 (maxloc(zgpg1(:,jlev)-zgpg2(:,jlev)),JLEV), ZGPG2 (maxloc(zgpg1(:,jlev)-zgpg2(:,jlev)),JLEV), maxloc(zgpg1(:,jlev)-zgpg2(:,jlev))
    WRITE (*, '(A16," ",I6," ",3E30.20)') CDNAME, JLEV, MAXVAL (ZGPG1 (:,JLEV)-ZGPG2 (:,JLEV)), MINVAL (ZGPG1 (:,JLEV)-ZGPG2 (:,JLEV)), SQRT (SUM ((ZGPG1 (:,JLEV)-ZGPG2 (:,JLEV)) * (ZGPG1 (:,JLEV)-ZGPG2 (:,JLEV))))

  ENDDO
ENDIF


END SUBROUTINE

SUBROUTINE SETUP

INTEGER (KIND=JPIM) :: NPRGPNS
INTEGER (KIND=JPIM) :: NPRGPEW
INTEGER (KIND=JPIM) :: NPRTRW
LOGICAL :: LEQ_REGIONS
REAL (KIND=JPRB) :: RA

INTEGER (KIND=JPIM) :: NSMAX
INTEGER (KIND=JPIM) :: NDGLG
INTEGER (KIND=JPIM) :: NRESOL
LOGICAL :: LSPLIT
LOGICAL :: LUSEFLT
LOGICAL :: LUSERPNM
LOGICAL :: LKEEPRPNM
LOGICAL :: LFFTW

#include "setup_trans0.h"
#include "setup_trans.h"

INTEGER :: ILUN

OPEN (ILUN, FILE=TRIM (CLCASE)//'/SETUP_TRANS0.IN', FORM='UNFORMATTED')
READ (ILUN) NPRGPNS
READ (ILUN) NPRGPEW
READ (ILUN) NPRTRW
READ (ILUN) LEQ_REGIONS
READ (ILUN) RA
CLOSE (ILUN)

CALL SETUP_TRANS0            &
  (KPRGPNS=NPRGPNS,          &
 & KPRGPEW=NPRGPEW,          &
 & KPRTRW=NPRTRW,            &
 & KPRINTLEV=IPRINTLEV,      &
 & LDEQ_REGIONS=LEQ_REGIONS, &
 & PRAD=RA)

OPEN (ILUN, FILE=TRIM (CLCASE)//'/SETUP_TRANS.IN', FORM='UNFORMATTED')

READ (ILUN) NSMAX
READ (ILUN) NDGLG
ALLOCATE (NLOENG (NDGLG))
READ (ILUN) NLOENG
READ (ILUN) LSPLIT
READ (ILUN) NRESOL
READ (ILUN) LUSEFLT
READ (ILUN) LUSERPNM
READ (ILUN) LKEEPRPNM
READ (ILUN) LFFTW
CLOSE (ILUN)


CALL SETUP_TRANS(KSMAX=NSMAX,KDGL=NDGLG,KLOEN=NLOENG(1:NDGLG),&
 & LDSPLIT=LSPLIT,KRESOL=NRESOL,LDUSEFLT=LUSEFLT,LDUSERPNM=LUSERPNM,&
 & LDKEEPRPNM=LKEEPRPNM,LDUSEFFTW=LFFTW)


END SUBROUTINE

SUBROUTINE SP2GP (PSPL, PGPL)

USE, INTRINSIC :: IEEE_ARITHMETIC, ONLY: IEEE_VALUE, IEEE_QUIET_NAN

REAL (KIND=JPRB), INTENT (IN)  :: PSPL (YDGEOMETRY%YRDIMV%NFLEVL,YDGEOMETRY%YRDIM%NSPEC2)
REAL (KIND=JPRB), INTENT (OUT) :: PGPL (YDGEOMETRY%YRGEM%NGPTOT,YDGEOMETRY%YRDIMV%NFLEVG,1)

#include "inv_trans.h"

REAL (KIND=JPRB) :: ZNAN
INTEGER (KIND=JPIM), ALLOCATABLE :: IVSET (:)

ZNAN = IEEE_VALUE (ZNAN, IEEE_QUIET_NAN)

PGPL = ZNAN

ALLOCATE (IVSET (YDGEOMETRY%YRDIMV%NFLEVG))
IVSET = YDGEOMETRY%YRMP%NBSETLEV

CALL INV_TRANS (PSPSCALAR=PSPL, KVSETSC=IVSET, KPROMA=YDGEOMETRY%YRGEM%NGPTOT, PGP=PGPL)

END SUBROUTINE

SUBROUTINE WRTEXT (PSPL, CDFILE)

USE ECCODES

REAL (KIND=JPRB),  INTENT (IN) :: PSPL (YDGEOMETRY%YRDIMV%NFLEVL,YDGEOMETRY%YRDIM%NSPEC2)
CHARACTER (LEN=*), INTENT (IN) :: CDFILE

#include "gath_grid.h"

REAL (KIND=JPRB) :: ZGPL (YDGEOMETRY%YRGEM%NGPTOT,YDGEOMETRY%YRDIMV%NFLEVG,1)
INTEGER (KIND=JPIM) :: JLEV, JLON
CHARACTER (LEN=64) :: CLFILE
INTEGER :: ILUN

ILUN = 77

CALL SP2GP (PSPL, ZGPL)

WRITE (CLFILE, '(I6.6)') MYPROC
CLFILE = TRIM (CDFILE)//'.'//TRIM (CLFILE)//'.txt'

OPEN (ILUN, FILE=TRIM (CLFILE), FORM='FORMATTED')

DO JLEV = 1, YDGEOMETRY%YRDIMV%NFLEVG
  WRITE (ILUN, *) " JLEV = ", JLEV
  DO JLON = 1, YDGEOMETRY%YRGEM%NGPTOT
    WRITE (ILUN, '(I6," ",F30.20)') JLON, ZGPL (JLON, JLEV, 1)
  ENDDO
ENDDO

CLOSE (ILUN)

END SUBROUTINE

SUBROUTINE WRGRIB (PSPL, CDFILE)

USE ECCODES

REAL (KIND=JPRB),  INTENT (IN) :: PSPL (YDGEOMETRY%YRDIMV%NFLEVL,YDGEOMETRY%YRDIM%NSPEC2)
CHARACTER (LEN=*), INTENT (IN) :: CDFILE

#include "gath_grid.h"

REAL (KIND=JPRB) :: ZGPL (YDGEOMETRY%YRGEM%NGPTOT,YDGEOMETRY%YRDIMV%NFLEVG,1)
REAL (KIND=JPRB), ALLOCATABLE :: ZGPG (:,:)
INTEGER (KIND=JPIM) :: JLEV, JLON
INTEGER (KIND=JPIM), ALLOCATABLE :: ITO (:)
INTEGER :: IGRIB, IFILE
CHARACTER (LEN=64) :: CLFILE

CALL SP2GP (PSPL, ZGPL)

IF (.FALSE.) THEN
DO JLEV = 1, YDGEOMETRY%YRDIMV%NFLEVG
  PRINT *, " JLEV = ", JLEV
  DO JLON = 1, YDGEOMETRY%YRGEM%NGPTOT
    WRITE (*, '(I6," ",F30.20)') JLON, ZGPL (JLON, JLEV, 1)
  ENDDO
ENDDO
ENDIF

ALLOCATE (ITO (YDGEOMETRY%YRDIMV%NFLEVG))
ITO = 1

IF (MYPROC == 1) THEN
  ALLOCATE (ZGPG (YDGEOMETRY%YRGEM%NGPTOTG, YDGEOMETRY%YRDIMV%NFLEVG))
  CALL GATH_GRID (KFGATHG=YDGEOMETRY%YRDIMV%NFLEVG, KTO=ITO, PGP=ZGPL, PGPG=ZGPG)
ELSE
  CALL GATH_GRID (KFGATHG=YDGEOMETRY%YRDIMV%NFLEVG, KTO=ITO, PGP=ZGPL)
ENDIF


IF (MYPROC == 1) THEN
  DO JLEV = 1, YDGEOMETRY%YRDIMV%NFLEVG
    WRITE (CLFILE, '(I6.6)') JLEV
    CLFILE = TRIM (CDFILE)//'.'//TRIM (CLFILE)//'.grb'
    CALL GRIB_NEW_FROM_SAMPLES (IGRIB,  'reduced_gg_ml_grib2')
    CALL GRIB_SET (IGRIB, 'parameterNumber', 255)
    CALL GRIB_SET (IGRIB, 'interpretationOfNumberOfPoints', 1)
    CALL GRIB_SET (IGRIB, 'global', 1)
    CALL GRIB_SET (IGRIB, 'gridType', 'reduced_gg')
    CALL GRIB_SET (IGRIB, 'pl', NLOENG)
    CALL GRIB_SET (IGRIB, 'packingType', 'grid_simple')
    CALL GRIB_SET (IGRIB, 'values', ZGPG (:, JLEV))
    CALL GRIB_OPEN_FILE (IFILE, TRIM (CLFILE), 'w')
    CALL GRIB_WRITE (IGRIB, IFILE)
    CALL GRIB_CLOSE_FILE (IFILE)
    CALL GRIB_RELEASE (IGRIB)
  ENDDO
ENDIF


END SUBROUTINE

END 

