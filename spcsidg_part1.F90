#if defined(_OPENACC)
SUBROUTINE SPCSIDG_PART1 (YDGEOMETRY, YDDYN, KSPEC2V, PSDIVP,PSPDIVP,&
  &ZSDIVPL,ZSPDIVPL,param_mxture, KMLOCSTA, KMLOCEND)
#else
SUBROUTINE SPCSIDG_PART1 (YDGEOMETRY, YDDYN, KSPEC2V, PSDIVP, PSPDIVP ,KMLOCSTA, KMLOCEND)
#endif
USE GEOMETRY_MOD , ONLY : GEOMETRY
USE PARKIND1     , ONLY : JPIM, JPRB
USE YOMHOOK      , ONLY : LHOOK, DR_HOOK, JPHOOK
USE YOMDYN       , ONLY : TDYN

!     ------------------------------------------------------------------

IMPLICIT NONE

TYPE(GEOMETRY)    ,INTENT(IN)    :: YDGEOMETRY
TYPE(TDYN)        ,INTENT(IN)    :: YDDYN
INTEGER(KIND=JPIM),INTENT(IN)    :: KSPEC2V
INTEGER(KIND=JPIM),INTENT(IN)    :: KMLOCSTA
INTEGER(KIND=JPIM),INTENT(IN)    :: KMLOCEND


REAL(KIND=JPRB),   INTENT(IN)    :: PSDIVP (KSPEC2V,YDGEOMETRY%YRDIMV%NFLEVG)
REAL(KIND=JPRB),   INTENT(INOUT) :: PSPDIVP(KSPEC2V,YDGEOMETRY%YRDIMV%NFLEVG)
#if defined(_OPENACC)
INTEGER(KIND=JPIM), PARAMETER    :: ITBLOC=62
INTEGER(KIND=JPIM), PARAMETER     :: IBLOCLEV=8
REAL(KIND=JPRB),   INTENT(IN)    :: param_mxture(:,:,:)
REAL(KIND=JPRB) :: PAS(ITBLOC+3,IBLOCLEV)
REAL(KIND=JPRB) :: PBS(ITBLOC+3,IBLOCLEV)
REAL(KIND=JPRB) :: PCS(ITBLOC+3,IBLOCLEV)
REAL(KIND=JPRB) :: PINS(ITBLOC+3,IBLOCLEV,2)
REAL(KIND=JPRB) :: POUTS(ITBLOC+3,IBLOCLEV,2)
REAL(KIND=JPRB),INTENT(INOUT)    :: ZSDIVPL (1:YDGEOMETRY%YRDIM%NSMAX+1,2,YDGEOMETRY%YRDIMV%NFLEVG,500)
REAL(KIND=JPRB),INTENT(INOUT)    :: ZSPDIVPL(1:YDGEOMETRY%YRDIM%NSMAX+1,2,YDGEOMETRY%YRDIMV%NFLEVG,500)

#else
REAL(KIND=JPRB) :: ZSDIVPL  (YDGEOMETRY%YRDIMV%NFLEVG,YDGEOMETRY%YRDIM%NSMAX+1,2)
REAL(KIND=JPRB) :: ZSPDIVPL (YDGEOMETRY%YRDIMV%NFLEVG,YDGEOMETRY%YRDIM%NSMAX+1,2)
#endif

INTEGER(KIND=JPIM) :: II, IS0, IS02, ISE, JN,JCNTV,JMLOC,JI,IOFFSET1,KLX
INTEGER(KIND=JPIM) :: IM, ISTA, IEND,JL,JLB,IOFFSET2,IREM,JCNTVC,JCNTVB

REAL(KIND=JPHOOK) :: ZHOOK_HANDLE

!     ------------------------------------------------------------------

#include "mxture.h"
#include "mxturs.h"

!     ------------------------------------------------------------------

ASSOCIATE(YDDIM=>YDGEOMETRY%YRDIM,YDDIMV=>YDGEOMETRY%YRDIMV,YDLAP=>YDGEOMETRY%YRLAP,YDMP=>YDGEOMETRY%YRMP)
ASSOCIATE(NSMAX=>YDDIM%NSMAX,NFLEVG=>YDDIMV%NFLEVG,SIHEG=>YDDYN%SIHEG,SIHEG2=>YDDYN%SIHEG2,NSPSTAF=>YDMP%NSPSTAF)

!             Inversion of two tridiagonal systems (Helmholtz equation)
!                --> (SIMI*DIVprIM(t+dt)).

!$ACC DATA PRESENT(PSDIVP,PSPDIVP,NSMAX,NFLEVG) CREATE(PAS,PBS,PBS,PINS,POUTS)
!$ACC DATA PRESENT(YDLAP,YDLAP%MYMS,NSPSTAF,SIHEG,SIHEG2,param_mxture,ZSDIVPL,ZSPDIVPL)

#if defined(_OPENACC)

!$ACC PARALLEL PRIVATE(II,IM,ISTA,KLX,PAS,PBS,PCS,PINS,POUTS,JLB,IOFFSET2,IREM,JCNTV,IOFFSET1) DEFAULT(NONE)
!$ACC CACHE(PAS(1:ITBLOC+3,1:IBLOCLEV),PBS(1:ITBLOC+3,1:IBLOCLEV),PCS(1:ITBLOC+3,1:IBLOCLEV),PINS(1:ITBLOC+3,1:IBLOCLEV,1:2),POUTS(1:ITBLOC+3,1:IBLOCLEV,1:2))
!$ACC LOOP GANG COLLAPSE(2) 
do JMLOC=KMLOCSTA,KMLOCEND
  do JCNTVB=1,(NFLEVG-1)/IBLOCLEV+1

      IM=YDLAP%MYMS(JMLOC)
      ISTA=NSPSTAF(IM)
      KLX=NSMAX+1-IM
      II=MIN(IM,1)+1
      !!zsdivpl(:,:,(JCNTVB-1)*IBLOCLEV+1:MIN(NFLEVG,JCNTVB*IBLOCLEV),JMLOC)=0.0_JPRB
      !!zspdivpl(:,:,(JCNTVB-1)*IBLOCLEV+1:MIN(NFLEVG,JCNTVB*IBLOCLEV),JMLOC)=0.0_JPRB
     
      !$ACC LOOP VECTOR PRIVATE(ISE,JCNTVC,JCNTV,JI)      
      DO JN=IM,NSMAX
        ISE=ISTA+2*(JN-IM)
        DO JCNTVC=1,MIN(IBLOCLEV,NFLEVG-(JCNTVB-1)*IBLOCLEV)
          JCNTV=JCNTVC+(JCNTVB-1)*IBLOCLEV
          DO JI=1,2
            ZSDIVPL(JN-IM+1,JI,JCNTV,JMLOC)=PSDIVP(ISE+JI-1,JCNTV)
          ENDDO
        ENDDO
      ENDDO 

      JCNTV=(JCNTVB-1)*IBLOCLEV
      IOFFSET1=JCNTV*(NSMAX+1-IM)
     
      IF (IM > 0) THEN

        !               Inversion of a symmetric matrix.

        CALL MXTURS(NSMAX+1-IM,MIN(IBLOCLEV,NFLEVG-JCNTV),IBLOCLEV,II,2,NSMAX,&
          & param_mxture(IOFFSET1+1,JMLOC,1),param_mxture(IOFFSET1+1,JMLOC,2),&
          & param_mxture(IOFFSET1+1,JMLOC,3),&
          & ZSDIVPL(1,1,1+JCNTV,JMLOC),ZSPDIVPL(1,1,1+JCNTV,JMLOC),&
          & ITBLOC,PAS,PBS,PCS,PINS,POUTS)    

     ELSE
      DO JI=1,2
        !               Inversion of a non-symmetric matrix.
        IF (JI==1) THEN

          CALL MXTURE(NSMAX+1-IM,MIN(IBLOCLEV,NFLEVG-JCNTV),IBLOCLEV,II,2,NSMAX,-2,.TRUE.,&
            & param_mxture(IOFFSET1+1,JMLOC,1),param_mxture(IOFFSET1+1,JMLOC,2),&
            & param_mxture(IOFFSET1+1,JMLOC,3),&
            & ZSDIVPL(1,1,1+JCNTV,JMLOC),ZSPDIVPL(1,1,1+JCNTV,JMLOC),&
            & ITBLOC,PAS,PBS,PCS,PINS,POUTS)

          CALL MXTURE(NSMAX+1-IM,MIN(IBLOCLEV,NFLEVG-JCNTV),IBLOCLEV,II,2,NSMAX,3,.FALSE.,&
            & param_mxture(IOFFSET1+1,JMLOC,1),param_mxture(IOFFSET1+1,JMLOC,4),&
            & param_mxture(IOFFSET1+1,JMLOC,5),&
            & ZSDIVPL(1,1,1+JCNTV,JMLOC),ZSPDIVPL(1,1,1+JCNTV,JMLOC),&
            & ITBLOC,PAS,PBS,PCS,PINS,POUTS) 

        ELSE
          !$ACC LOOP VECTOR PRIVATE(JCNTV,JCNTVC)
          DO JN=1,NSMAX+1-IM
            DO JCNTVC=1,MIN(IBLOCLEV,NFLEVG-(JCNTVB-1)*IBLOCLEV)
              JCNTV=JCNTVC+(JCNTVB-1)*IBLOCLEV
              ZSPDIVPL(JN,JI,JCNTV,JMLOC)=0.0_JPRB !!zsdivpl(jn,JI,JCNTV,JMLOC)
            ENDDO
          ENDDO
        ENDIF
       ENDDO !!JI IM 0
      ENDIF

      !$ACC LOOP VECTOR PRIVATE(ise,JCNTVC,JCNTV,JI) 
      DO JN=IM,NSMAX
        ISE=ISTA+2*(JN-IM)
        DO JCNTVC=1,MIN(IBLOCLEV,NFLEVG-(JCNTVB-1)*IBLOCLEV)          
          JCNTV=JCNTVC+(JCNTVB-1)*IBLOCLEV
          DO JI=1,2
            PSPDIVP(ISE+JI-1,JCNTV)=ZSPDIVPL(JN-IM+1,JI,JCNTV,JMLOC)
          ENDDO
        ENDDO
      ENDDO
  ENDDO  !!JCNTV
ENDDO    !!JMLOC
!$ACC END PARALLEL

!$ACC END DATA
!$ACC END DATA

#else

!$OMP PARALLEL DO PRIVATE(JMLOC,IM,ISTA,IEND,IS0,IS02,II,JN,ISE,ZSDIVPLl,ZSPDIVPL)
do JMLOC=KMLOCSTA,KMLOCEND

IM=YDLAP%MYMS(JMLOC)
ISTA=NSPSTAF(IM)
IEND=ISTA+2*(NSMAX+1-IM)-1

IS0=YDLAP%NSE0L(JMLOC)
IS02=0
II=MIN(IM,1)+1
ZSDIVPL(:,:,:)=0.0_JPRB
ZSPDIVPL(:,:,:)=0.0_JPRB

DO JN=IM,NSMAX
    ISE=ISTA+2*(JN-IM)
    ZSDIVPL(:,JN-IM+1,1)=PSDIVP(ISE,:)
    ZSDIVPL(:,JN-IM+1,2)=PSDIVP(ISE+1,:)
ENDDO

IF (IM > 0) THEN

  !               Inversion of a symmetric matrix.
  CALL MXTURS(NSMAX+1-IM,NFLEVG,NFLEVG,II,NSMAX,&
   & SIHEG(1,IS0+1,1),SIHEG(1,IS0+1,2),SIHEG(1,IS0+1,3),&
   & ZSDIVPL,ZSPDIVPL)  
ELSE

  !               Inversion of a non-symmetric matrix.
  CALL MXTURE(NSMAX+1-IM,NFLEVG,NFLEVG,II,NSMAX,-2,.TRUE.,&
   & SIHEG(1,IS0+1,1),SIHEG(1,IS0+1,2),SIHEG(1,IS0+1,3),&
   & ZSDIVPL,ZSPDIVPL)  
  CALL MXTURE(NSMAX+1-IM,NFLEVG,NFLEVG,II,NSMAX,3,.FALSE.,&
   & SIHEG(1,IS0+1,1),SIHEG2(1,IS02+1,2),&
   & SIHEG2(1,IS02+1,3),ZSDIVPL,ZSPDIVPL)
ENDIF

DO JN=IM,NSMAX
!!  do JCNTV=1,NFLEVG
    ISE=ISTA+2*(JN-IM)
    PSPDIVP(ISE,:)=ZSPDIVPL(:,JN-IM+1,1)
    PSPDIVP(ISE+1,:)=ZSPDIVPL(:,JN-IM+1,2)
!!  enddo
ENDDO

ENDDO !!JMLOC
!$OMP END PARALLEL DO

#endif

END ASSOCIATE
END ASSOCIATE

END SUBROUTINE SPCSIDG_PART1

