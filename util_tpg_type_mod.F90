MODULE UTIL_TPG_TYPE_MOD

USE INTDYN_MOD, ONLY : TPG_TYPE

INTERFACE SAVE
MODULE PROCEDURE SAVE_TPG_TYPE
END INTERFACE

INTERFACE LOAD
MODULE PROCEDURE LOAD_TPG_TYPE
END INTERFACE

INTERFACE COPY
MODULE PROCEDURE COPY_TPG_TYPE
END INTERFACE

INTERFACE WIPE
MODULE PROCEDURE WIPE_TPG_TYPE
END INTERFACE



CONTAINS

SUBROUTINE SAVE_TPG_TYPE (KLUN, YD)

IMPLICIT NONE
INTEGER, INTENT (IN) :: KLUN
TYPE (TPG_TYPE), INTENT (IN), TARGET :: YD
LOGICAL :: LPHI0F, LPHI0FL, LPHI0FM, LPHI0H, LPHI0HL, LPHI0HM, LPSGRTL, LPSGRTM, LRT0, LRT0L
LOGICAL :: LRT0M
LPHI0F = ASSOCIATED (YD%PHI0F)
WRITE (KLUN) LPHI0F
IF (LPHI0F) THEN
  WRITE (KLUN) LBOUND (YD%PHI0F)
  WRITE (KLUN) UBOUND (YD%PHI0F)
  WRITE (KLUN) YD%PHI0F
ENDIF
LPHI0FL = ASSOCIATED (YD%PHI0FL)
WRITE (KLUN) LPHI0FL
IF (LPHI0FL) THEN
  WRITE (KLUN) LBOUND (YD%PHI0FL)
  WRITE (KLUN) UBOUND (YD%PHI0FL)
  WRITE (KLUN) YD%PHI0FL
ENDIF
LPHI0FM = ASSOCIATED (YD%PHI0FM)
WRITE (KLUN) LPHI0FM
IF (LPHI0FM) THEN
  WRITE (KLUN) LBOUND (YD%PHI0FM)
  WRITE (KLUN) UBOUND (YD%PHI0FM)
  WRITE (KLUN) YD%PHI0FM
ENDIF
LRT0 = ASSOCIATED (YD%RT0)
WRITE (KLUN) LRT0
IF (LRT0) THEN
  WRITE (KLUN) LBOUND (YD%RT0)
  WRITE (KLUN) UBOUND (YD%RT0)
  WRITE (KLUN) YD%RT0
ENDIF
LRT0L = ASSOCIATED (YD%RT0L)
WRITE (KLUN) LRT0L
IF (LRT0L) THEN
  WRITE (KLUN) LBOUND (YD%RT0L)
  WRITE (KLUN) UBOUND (YD%RT0L)
  WRITE (KLUN) YD%RT0L
ENDIF
LRT0M = ASSOCIATED (YD%RT0M)
WRITE (KLUN) LRT0M
IF (LRT0M) THEN
  WRITE (KLUN) LBOUND (YD%RT0M)
  WRITE (KLUN) UBOUND (YD%RT0M)
  WRITE (KLUN) YD%RT0M
ENDIF
LPHI0H = ASSOCIATED (YD%PHI0H)
WRITE (KLUN) LPHI0H
IF (LPHI0H) THEN
  WRITE (KLUN) LBOUND (YD%PHI0H)
  WRITE (KLUN) UBOUND (YD%PHI0H)
  WRITE (KLUN) YD%PHI0H
ENDIF
LPHI0HL = ASSOCIATED (YD%PHI0HL)
WRITE (KLUN) LPHI0HL
IF (LPHI0HL) THEN
  WRITE (KLUN) LBOUND (YD%PHI0HL)
  WRITE (KLUN) UBOUND (YD%PHI0HL)
  WRITE (KLUN) YD%PHI0HL
ENDIF
LPHI0HM = ASSOCIATED (YD%PHI0HM)
WRITE (KLUN) LPHI0HM
IF (LPHI0HM) THEN
  WRITE (KLUN) LBOUND (YD%PHI0HM)
  WRITE (KLUN) UBOUND (YD%PHI0HM)
  WRITE (KLUN) YD%PHI0HM
ENDIF
LPSGRTL = ASSOCIATED (YD%PSGRTL)
WRITE (KLUN) LPSGRTL
IF (LPSGRTL) THEN
  WRITE (KLUN) LBOUND (YD%PSGRTL)
  WRITE (KLUN) UBOUND (YD%PSGRTL)
  WRITE (KLUN) YD%PSGRTL
ENDIF
LPSGRTM = ASSOCIATED (YD%PSGRTM)
WRITE (KLUN) LPSGRTM
IF (LPSGRTM) THEN
  WRITE (KLUN) LBOUND (YD%PSGRTM)
  WRITE (KLUN) UBOUND (YD%PSGRTM)
  WRITE (KLUN) YD%PSGRTM
ENDIF
END SUBROUTINE

SUBROUTINE LOAD_TPG_TYPE (KLUN, YD)
USE PARKIND1, ONLY : JPRD

IMPLICIT NONE
INTEGER, INTENT (IN) :: KLUN
TYPE (TPG_TYPE), INTENT (OUT), TARGET :: YD
INTEGER :: IL2(2), IU2(2)
LOGICAL :: LPHI0F, LPHI0FL, LPHI0FM, LPHI0H, LPHI0HL, LPHI0HM, LPSGRTL, LPSGRTM, LRT0, LRT0L
LOGICAL :: LRT0M
REAL(KIND=JPRD), ALLOCATABLE :: ZTMP2 (:,:)
READ (KLUN) LPHI0F
IF (LPHI0F) THEN
  READ (KLUN) IL2
  READ (KLUN) IU2
  ALLOCATE (YD%PHI0F (IL2(1):IU2(1), IL2(2):IU2(2)))
  ALLOCATE (ZTMP2(LBOUND(YD%PHI0F,1):UBOUND(YD%PHI0F,1), LBOUND(YD%PHI0F,2):UBOUND(YD%PHI0F,2)))
  READ (KLUN) ZTMP2
  YD%PHI0F = ZTMP2
  DEALLOCATE (ZTMP2)
ELSE
  NULLIFY (YD%PHI0F)
ENDIF
READ (KLUN) LPHI0FL
IF (LPHI0FL) THEN
  READ (KLUN) IL2
  READ (KLUN) IU2
  ALLOCATE (YD%PHI0FL (IL2(1):IU2(1), IL2(2):IU2(2)))
  ALLOCATE (ZTMP2(LBOUND(YD%PHI0FL,1):UBOUND(YD%PHI0FL,1), LBOUND(YD%PHI0FL,2):UBOUND(YD%PHI0FL,2)))
  READ (KLUN) ZTMP2
  YD%PHI0FL = ZTMP2
  DEALLOCATE (ZTMP2)
ELSE
  NULLIFY (YD%PHI0FL)
ENDIF
READ (KLUN) LPHI0FM
IF (LPHI0FM) THEN
  READ (KLUN) IL2
  READ (KLUN) IU2
  ALLOCATE (YD%PHI0FM (IL2(1):IU2(1), IL2(2):IU2(2)))
  ALLOCATE (ZTMP2(LBOUND(YD%PHI0FM,1):UBOUND(YD%PHI0FM,1), LBOUND(YD%PHI0FM,2):UBOUND(YD%PHI0FM,2)))
  READ (KLUN) ZTMP2
  YD%PHI0FM = ZTMP2
  DEALLOCATE (ZTMP2)
ELSE
  NULLIFY (YD%PHI0FM)
ENDIF
READ (KLUN) LRT0
IF (LRT0) THEN
  READ (KLUN) IL2
  READ (KLUN) IU2
  ALLOCATE (YD%RT0 (IL2(1):IU2(1), IL2(2):IU2(2)))
  ALLOCATE (ZTMP2(LBOUND(YD%RT0,1):UBOUND(YD%RT0,1), LBOUND(YD%RT0,2):UBOUND(YD%RT0,2)))
  READ (KLUN) ZTMP2
  YD%RT0 = ZTMP2
  DEALLOCATE (ZTMP2)
ELSE
  NULLIFY (YD%RT0)
ENDIF
READ (KLUN) LRT0L
IF (LRT0L) THEN
  READ (KLUN) IL2
  READ (KLUN) IU2
  ALLOCATE (YD%RT0L (IL2(1):IU2(1), IL2(2):IU2(2)))
  ALLOCATE (ZTMP2(LBOUND(YD%RT0L,1):UBOUND(YD%RT0L,1), LBOUND(YD%RT0L,2):UBOUND(YD%RT0L,2)))
  READ (KLUN) ZTMP2
  YD%RT0L = ZTMP2
  DEALLOCATE (ZTMP2)
ELSE
  NULLIFY (YD%RT0L)
ENDIF
READ (KLUN) LRT0M
IF (LRT0M) THEN
  READ (KLUN) IL2
  READ (KLUN) IU2
  ALLOCATE (YD%RT0M (IL2(1):IU2(1), IL2(2):IU2(2)))
  ALLOCATE (ZTMP2(LBOUND(YD%RT0M,1):UBOUND(YD%RT0M,1), LBOUND(YD%RT0M,2):UBOUND(YD%RT0M,2)))
  READ (KLUN) ZTMP2
  YD%RT0M = ZTMP2
  DEALLOCATE (ZTMP2)
ELSE
  NULLIFY (YD%RT0M)
ENDIF
READ (KLUN) LPHI0H
IF (LPHI0H) THEN
  READ (KLUN) IL2
  READ (KLUN) IU2
  ALLOCATE (YD%PHI0H (IL2(1):IU2(1), IL2(2):IU2(2)))
  ALLOCATE (ZTMP2(LBOUND(YD%PHI0H,1):UBOUND(YD%PHI0H,1), LBOUND(YD%PHI0H,2):UBOUND(YD%PHI0H,2)))
  READ (KLUN) ZTMP2
  YD%PHI0H = ZTMP2
  DEALLOCATE (ZTMP2)
ELSE
  NULLIFY (YD%PHI0H)
ENDIF
READ (KLUN) LPHI0HL
IF (LPHI0HL) THEN
  READ (KLUN) IL2
  READ (KLUN) IU2
  ALLOCATE (YD%PHI0HL (IL2(1):IU2(1), IL2(2):IU2(2)))
  ALLOCATE (ZTMP2(LBOUND(YD%PHI0HL,1):UBOUND(YD%PHI0HL,1), LBOUND(YD%PHI0HL,2):UBOUND(YD%PHI0HL,2)))
  READ (KLUN) ZTMP2
  YD%PHI0HL = ZTMP2
  DEALLOCATE (ZTMP2)
ELSE
  NULLIFY (YD%PHI0HL)
ENDIF
READ (KLUN) LPHI0HM
IF (LPHI0HM) THEN
  READ (KLUN) IL2
  READ (KLUN) IU2
  ALLOCATE (YD%PHI0HM (IL2(1):IU2(1), IL2(2):IU2(2)))
  ALLOCATE (ZTMP2(LBOUND(YD%PHI0HM,1):UBOUND(YD%PHI0HM,1), LBOUND(YD%PHI0HM,2):UBOUND(YD%PHI0HM,2)))
  READ (KLUN) ZTMP2
  YD%PHI0HM = ZTMP2
  DEALLOCATE (ZTMP2)
ELSE
  NULLIFY (YD%PHI0HM)
ENDIF
READ (KLUN) LPSGRTL
IF (LPSGRTL) THEN
  READ (KLUN) IL2
  READ (KLUN) IU2
  ALLOCATE (YD%PSGRTL (IL2(1):IU2(1), IL2(2):IU2(2)))
  ALLOCATE (ZTMP2(LBOUND(YD%PSGRTL,1):UBOUND(YD%PSGRTL,1), LBOUND(YD%PSGRTL,2):UBOUND(YD%PSGRTL,2)))
  READ (KLUN) ZTMP2
  YD%PSGRTL = ZTMP2
  DEALLOCATE (ZTMP2)
ELSE
  NULLIFY (YD%PSGRTL)
ENDIF
READ (KLUN) LPSGRTM
IF (LPSGRTM) THEN
  READ (KLUN) IL2
  READ (KLUN) IU2
  ALLOCATE (YD%PSGRTM (IL2(1):IU2(1), IL2(2):IU2(2)))
  ALLOCATE (ZTMP2(LBOUND(YD%PSGRTM,1):UBOUND(YD%PSGRTM,1), LBOUND(YD%PSGRTM,2):UBOUND(YD%PSGRTM,2)))
  READ (KLUN) ZTMP2
  YD%PSGRTM = ZTMP2
  DEALLOCATE (ZTMP2)
ELSE
  NULLIFY (YD%PSGRTM)
ENDIF
END SUBROUTINE


SUBROUTINE COPY_TPG_TYPE (YD, LDCREATED)

IMPLICIT NONE
TYPE (TPG_TYPE), INTENT (IN), TARGET :: YD
LOGICAL, OPTIONAL, INTENT (IN) :: LDCREATED
LOGICAL :: LLCREATED
LOGICAL :: LPHI0F, LPHI0FL, LPHI0FM, LPHI0H, LPHI0HL, LPHI0HM, LPSGRTL, LPSGRTM, LRT0, LRT0L
LOGICAL :: LRT0M

LLCREATED = .FALSE.
IF (PRESENT (LDCREATED)) THEN
  LLCREATED = LDCREATED
ENDIF
IF (.NOT. LLCREATED) THEN
  !$acc enter data create (YD)
  !$acc update device (YD)
ENDIF
LPHI0F = ASSOCIATED (YD%PHI0F)
IF (LPHI0F) THEN
  !$acc enter data create (YD%PHI0F)
  !$acc update device (YD%PHI0F)
  !$acc enter data attach (YD%PHI0F)
ENDIF

LPHI0FL = ASSOCIATED (YD%PHI0FL)
IF (LPHI0FL) THEN
  !$acc enter data create (YD%PHI0FL)
  !$acc update device (YD%PHI0FL)
  !$acc enter data attach (YD%PHI0FL)
ENDIF

LPHI0FM = ASSOCIATED (YD%PHI0FM)
IF (LPHI0FM) THEN
  !$acc enter data create (YD%PHI0FM)
  !$acc update device (YD%PHI0FM)
  !$acc enter data attach (YD%PHI0FM)
ENDIF

LRT0 = ASSOCIATED (YD%RT0)
IF (LRT0) THEN
  !$acc enter data create (YD%RT0)
  !$acc update device (YD%RT0)
  !$acc enter data attach (YD%RT0)
ENDIF

LRT0L = ASSOCIATED (YD%RT0L)
IF (LRT0L) THEN
  !$acc enter data create (YD%RT0L)
  !$acc update device (YD%RT0L)
  !$acc enter data attach (YD%RT0L)
ENDIF

LRT0M = ASSOCIATED (YD%RT0M)
IF (LRT0M) THEN
  !$acc enter data create (YD%RT0M)
  !$acc update device (YD%RT0M)
  !$acc enter data attach (YD%RT0M)
ENDIF

LPHI0H = ASSOCIATED (YD%PHI0H)
IF (LPHI0H) THEN
  !$acc enter data create (YD%PHI0H)
  !$acc update device (YD%PHI0H)
  !$acc enter data attach (YD%PHI0H)
ENDIF

LPHI0HL = ASSOCIATED (YD%PHI0HL)
IF (LPHI0HL) THEN
  !$acc enter data create (YD%PHI0HL)
  !$acc update device (YD%PHI0HL)
  !$acc enter data attach (YD%PHI0HL)
ENDIF

LPHI0HM = ASSOCIATED (YD%PHI0HM)
IF (LPHI0HM) THEN
  !$acc enter data create (YD%PHI0HM)
  !$acc update device (YD%PHI0HM)
  !$acc enter data attach (YD%PHI0HM)
ENDIF

LPSGRTL = ASSOCIATED (YD%PSGRTL)
IF (LPSGRTL) THEN
  !$acc enter data create (YD%PSGRTL)
  !$acc update device (YD%PSGRTL)
  !$acc enter data attach (YD%PSGRTL)
ENDIF

LPSGRTM = ASSOCIATED (YD%PSGRTM)
IF (LPSGRTM) THEN
  !$acc enter data create (YD%PSGRTM)
  !$acc update device (YD%PSGRTM)
  !$acc enter data attach (YD%PSGRTM)
ENDIF

END SUBROUTINE

SUBROUTINE WIPE_TPG_TYPE (YD, LDDELETED)

IMPLICIT NONE
TYPE (TPG_TYPE), INTENT (IN), TARGET :: YD
LOGICAL, OPTIONAL, INTENT (IN) :: LDDELETED
LOGICAL :: LLDELETED
LOGICAL :: LPHI0F, LPHI0FL, LPHI0FM, LPHI0H, LPHI0HL, LPHI0HM, LPSGRTL, LPSGRTM, LRT0, LRT0L
LOGICAL :: LRT0M

LPHI0F = ASSOCIATED (YD%PHI0F)
IF (LPHI0F) THEN
  !$acc exit data detach (YD%PHI0F)
  !$acc exit data delete (YD%PHI0F)
ENDIF

LPHI0FL = ASSOCIATED (YD%PHI0FL)
IF (LPHI0FL) THEN
  !$acc exit data detach (YD%PHI0FL)
  !$acc exit data delete (YD%PHI0FL)
ENDIF

LPHI0FM = ASSOCIATED (YD%PHI0FM)
IF (LPHI0FM) THEN
  !$acc exit data detach (YD%PHI0FM)
  !$acc exit data delete (YD%PHI0FM)
ENDIF

LRT0 = ASSOCIATED (YD%RT0)
IF (LRT0) THEN
  !$acc exit data detach (YD%RT0)
  !$acc exit data delete (YD%RT0)
ENDIF

LRT0L = ASSOCIATED (YD%RT0L)
IF (LRT0L) THEN
  !$acc exit data detach (YD%RT0L)
  !$acc exit data delete (YD%RT0L)
ENDIF

LRT0M = ASSOCIATED (YD%RT0M)
IF (LRT0M) THEN
  !$acc exit data detach (YD%RT0M)
  !$acc exit data delete (YD%RT0M)
ENDIF

LPHI0H = ASSOCIATED (YD%PHI0H)
IF (LPHI0H) THEN
  !$acc exit data detach (YD%PHI0H)
  !$acc exit data delete (YD%PHI0H)
ENDIF

LPHI0HL = ASSOCIATED (YD%PHI0HL)
IF (LPHI0HL) THEN
  !$acc exit data detach (YD%PHI0HL)
  !$acc exit data delete (YD%PHI0HL)
ENDIF

LPHI0HM = ASSOCIATED (YD%PHI0HM)
IF (LPHI0HM) THEN
  !$acc exit data detach (YD%PHI0HM)
  !$acc exit data delete (YD%PHI0HM)
ENDIF

LPSGRTL = ASSOCIATED (YD%PSGRTL)
IF (LPSGRTL) THEN
  !$acc exit data detach (YD%PSGRTL)
  !$acc exit data delete (YD%PSGRTL)
ENDIF

LPSGRTM = ASSOCIATED (YD%PSGRTM)
IF (LPSGRTM) THEN
  !$acc exit data detach (YD%PSGRTM)
  !$acc exit data delete (YD%PSGRTM)
ENDIF

LLDELETED = .FALSE.
IF (PRESENT (LDDELETED)) THEN
  LLDELETED = LDDELETED
ENDIF
IF (.NOT. LLDELETED) THEN
  !$acc exit data delete (YD)
ENDIF
END SUBROUTINE



END MODULE
